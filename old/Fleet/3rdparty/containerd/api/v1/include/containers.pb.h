// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: containers.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_containers_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_containers_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogo.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_containers_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_containers_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_containers_2eproto;
namespace containerd {
namespace services {
namespace containers {
namespace v1 {
class Container;
struct ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class Container_ExtensionsEntry_DoNotUse;
struct Container_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern Container_ExtensionsEntry_DoNotUseDefaultTypeInternal _Container_ExtensionsEntry_DoNotUse_default_instance_;
class Container_LabelsEntry_DoNotUse;
struct Container_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Container_LabelsEntry_DoNotUseDefaultTypeInternal _Container_LabelsEntry_DoNotUse_default_instance_;
class Container_Runtime;
struct Container_RuntimeDefaultTypeInternal;
extern Container_RuntimeDefaultTypeInternal _Container_Runtime_default_instance_;
class CreateContainerRequest;
struct CreateContainerRequestDefaultTypeInternal;
extern CreateContainerRequestDefaultTypeInternal _CreateContainerRequest_default_instance_;
class CreateContainerResponse;
struct CreateContainerResponseDefaultTypeInternal;
extern CreateContainerResponseDefaultTypeInternal _CreateContainerResponse_default_instance_;
class DeleteContainerRequest;
struct DeleteContainerRequestDefaultTypeInternal;
extern DeleteContainerRequestDefaultTypeInternal _DeleteContainerRequest_default_instance_;
class GetContainerRequest;
struct GetContainerRequestDefaultTypeInternal;
extern GetContainerRequestDefaultTypeInternal _GetContainerRequest_default_instance_;
class GetContainerResponse;
struct GetContainerResponseDefaultTypeInternal;
extern GetContainerResponseDefaultTypeInternal _GetContainerResponse_default_instance_;
class ListContainerMessage;
struct ListContainerMessageDefaultTypeInternal;
extern ListContainerMessageDefaultTypeInternal _ListContainerMessage_default_instance_;
class ListContainersRequest;
struct ListContainersRequestDefaultTypeInternal;
extern ListContainersRequestDefaultTypeInternal _ListContainersRequest_default_instance_;
class ListContainersResponse;
struct ListContainersResponseDefaultTypeInternal;
extern ListContainersResponseDefaultTypeInternal _ListContainersResponse_default_instance_;
class UpdateContainerRequest;
struct UpdateContainerRequestDefaultTypeInternal;
extern UpdateContainerRequestDefaultTypeInternal _UpdateContainerRequest_default_instance_;
class UpdateContainerResponse;
struct UpdateContainerResponseDefaultTypeInternal;
extern UpdateContainerResponseDefaultTypeInternal _UpdateContainerResponse_default_instance_;
}  // namespace v1
}  // namespace containers
}  // namespace services
}  // namespace containerd
PROTOBUF_NAMESPACE_OPEN
template<> ::containerd::services::containers::v1::Container* Arena::CreateMaybeMessage<::containerd::services::containers::v1::Container>(Arena*);
template<> ::containerd::services::containers::v1::Container_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::Container_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::containers::v1::Container_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::Container_LabelsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::containers::v1::Container_Runtime* Arena::CreateMaybeMessage<::containerd::services::containers::v1::Container_Runtime>(Arena*);
template<> ::containerd::services::containers::v1::CreateContainerRequest* Arena::CreateMaybeMessage<::containerd::services::containers::v1::CreateContainerRequest>(Arena*);
template<> ::containerd::services::containers::v1::CreateContainerResponse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::CreateContainerResponse>(Arena*);
template<> ::containerd::services::containers::v1::DeleteContainerRequest* Arena::CreateMaybeMessage<::containerd::services::containers::v1::DeleteContainerRequest>(Arena*);
template<> ::containerd::services::containers::v1::GetContainerRequest* Arena::CreateMaybeMessage<::containerd::services::containers::v1::GetContainerRequest>(Arena*);
template<> ::containerd::services::containers::v1::GetContainerResponse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::GetContainerResponse>(Arena*);
template<> ::containerd::services::containers::v1::ListContainerMessage* Arena::CreateMaybeMessage<::containerd::services::containers::v1::ListContainerMessage>(Arena*);
template<> ::containerd::services::containers::v1::ListContainersRequest* Arena::CreateMaybeMessage<::containerd::services::containers::v1::ListContainersRequest>(Arena*);
template<> ::containerd::services::containers::v1::ListContainersResponse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::ListContainersResponse>(Arena*);
template<> ::containerd::services::containers::v1::UpdateContainerRequest* Arena::CreateMaybeMessage<::containerd::services::containers::v1::UpdateContainerRequest>(Arena*);
template<> ::containerd::services::containers::v1::UpdateContainerResponse* Arena::CreateMaybeMessage<::containerd::services::containers::v1::UpdateContainerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace containerd {
namespace services {
namespace containers {
namespace v1 {

// ===================================================================

class Container_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Container_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Container_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Container_LabelsEntry_DoNotUse();
  explicit constexpr Container_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Container_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Container_LabelsEntry_DoNotUse& other);
  static const Container_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Container_LabelsEntry_DoNotUse*>(&_Container_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.containers.v1.Container.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.containers.v1.Container.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Container_Runtime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.Container.Runtime) */ {
 public:
  inline Container_Runtime() : Container_Runtime(nullptr) {}
  ~Container_Runtime() override;
  explicit constexpr Container_Runtime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Container_Runtime(const Container_Runtime& from);
  Container_Runtime(Container_Runtime&& from) noexcept
    : Container_Runtime() {
    *this = ::std::move(from);
  }

  inline Container_Runtime& operator=(const Container_Runtime& from) {
    CopyFrom(from);
    return *this;
  }
  inline Container_Runtime& operator=(Container_Runtime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Container_Runtime& default_instance() {
    return *internal_default_instance();
  }
  static inline const Container_Runtime* internal_default_instance() {
    return reinterpret_cast<const Container_Runtime*>(
               &_Container_Runtime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Container_Runtime& a, Container_Runtime& b) {
    a.Swap(&b);
  }
  inline void Swap(Container_Runtime* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Container_Runtime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Container_Runtime* New() const final {
    return new Container_Runtime();
  }

  Container_Runtime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Container_Runtime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Container_Runtime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Container_Runtime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container_Runtime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.Container.Runtime";
  }
  protected:
  explicit Container_Runtime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Any options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const PROTOBUF_NAMESPACE_ID::Any& options() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_options();
  PROTOBUF_NAMESPACE_ID::Any* mutable_options();
  void set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_options() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      PROTOBUF_NAMESPACE_ID::Any* options);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.Container.Runtime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  PROTOBUF_NAMESPACE_ID::Any* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class Container_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Container_ExtensionsEntry_DoNotUse, 
    std::string, PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Container_ExtensionsEntry_DoNotUse, 
    std::string, PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Container_ExtensionsEntry_DoNotUse();
  explicit constexpr Container_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Container_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Container_ExtensionsEntry_DoNotUse& other);
  static const Container_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Container_ExtensionsEntry_DoNotUse*>(&_Container_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.containers.v1.Container.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Container final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.Container) */ {
 public:
  inline Container() : Container(nullptr) {}
  ~Container() override;
  explicit constexpr Container(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Container(const Container& from);
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  inline Container& operator=(Container&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Container& default_instance() {
    return *internal_default_instance();
  }
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }
  inline void Swap(Container* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Container* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const final {
    return new Container();
  }

  Container* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Container>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Container& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Container& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.Container";
  }
  protected:
  explicit Container(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Container_Runtime Runtime;

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 2,
    kExtensionsFieldNumber = 10,
    kIdFieldNumber = 1,
    kImageFieldNumber = 3,
    kSnapshotterFieldNumber = 6,
    kSnapshotKeyFieldNumber = 7,
    kRuntimeFieldNumber = 4,
    kSpecFieldNumber = 5,
    kCreatedAtFieldNumber = 8,
    kUpdatedAtFieldNumber = 9,
  };
  // map<string, string> labels = 2;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, .google.protobuf.Any> extensions = 10 [(.gogoproto.nullable) = false];
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >*
      mutable_extensions();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string image = 3;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_MUST_USE_RESULT std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // string snapshotter = 6;
  void clear_snapshotter();
  const std::string& snapshotter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snapshotter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snapshotter();
  PROTOBUF_MUST_USE_RESULT std::string* release_snapshotter();
  void set_allocated_snapshotter(std::string* snapshotter);
  private:
  const std::string& _internal_snapshotter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshotter(const std::string& value);
  std::string* _internal_mutable_snapshotter();
  public:

  // string snapshot_key = 7;
  void clear_snapshot_key();
  const std::string& snapshot_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snapshot_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snapshot_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_snapshot_key();
  void set_allocated_snapshot_key(std::string* snapshot_key);
  private:
  const std::string& _internal_snapshot_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_key(const std::string& value);
  std::string* _internal_mutable_snapshot_key();
  public:

  // .containerd.services.containers.v1.Container.Runtime runtime = 4;
  bool has_runtime() const;
  private:
  bool _internal_has_runtime() const;
  public:
  void clear_runtime();
  const ::containerd::services::containers::v1::Container_Runtime& runtime() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container_Runtime* release_runtime();
  ::containerd::services::containers::v1::Container_Runtime* mutable_runtime();
  void set_allocated_runtime(::containerd::services::containers::v1::Container_Runtime* runtime);
  private:
  const ::containerd::services::containers::v1::Container_Runtime& _internal_runtime() const;
  ::containerd::services::containers::v1::Container_Runtime* _internal_mutable_runtime();
  public:
  void unsafe_arena_set_allocated_runtime(
      ::containerd::services::containers::v1::Container_Runtime* runtime);
  ::containerd::services::containers::v1::Container_Runtime* unsafe_arena_release_runtime();

  // .google.protobuf.Any spec = 5;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const PROTOBUF_NAMESPACE_ID::Any& spec() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_spec();
  PROTOBUF_NAMESPACE_ID::Any* mutable_spec();
  void set_allocated_spec(PROTOBUF_NAMESPACE_ID::Any* spec);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_spec() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      PROTOBUF_NAMESPACE_ID::Any* spec);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_spec();

  // .google.protobuf.Timestamp created_at = 8 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 9 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.Container)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Container_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Container_ExtensionsEntry_DoNotUse,
      std::string, PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshotter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_key_;
  ::containerd::services::containers::v1::Container_Runtime* runtime_;
  PROTOBUF_NAMESPACE_ID::Any* spec_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class GetContainerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.GetContainerRequest) */ {
 public:
  inline GetContainerRequest() : GetContainerRequest(nullptr) {}
  ~GetContainerRequest() override;
  explicit constexpr GetContainerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetContainerRequest(const GetContainerRequest& from);
  GetContainerRequest(GetContainerRequest&& from) noexcept
    : GetContainerRequest() {
    *this = ::std::move(from);
  }

  inline GetContainerRequest& operator=(const GetContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetContainerRequest& operator=(GetContainerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetContainerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetContainerRequest* internal_default_instance() {
    return reinterpret_cast<const GetContainerRequest*>(
               &_GetContainerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetContainerRequest& a, GetContainerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetContainerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetContainerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetContainerRequest* New() const final {
    return new GetContainerRequest();
  }

  GetContainerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetContainerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetContainerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetContainerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetContainerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.GetContainerRequest";
  }
  protected:
  explicit GetContainerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.GetContainerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class GetContainerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.GetContainerResponse) */ {
 public:
  inline GetContainerResponse() : GetContainerResponse(nullptr) {}
  ~GetContainerResponse() override;
  explicit constexpr GetContainerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetContainerResponse(const GetContainerResponse& from);
  GetContainerResponse(GetContainerResponse&& from) noexcept
    : GetContainerResponse() {
    *this = ::std::move(from);
  }

  inline GetContainerResponse& operator=(const GetContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetContainerResponse& operator=(GetContainerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetContainerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetContainerResponse* internal_default_instance() {
    return reinterpret_cast<const GetContainerResponse*>(
               &_GetContainerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetContainerResponse& a, GetContainerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetContainerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetContainerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetContainerResponse* New() const final {
    return new GetContainerResponse();
  }

  GetContainerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetContainerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetContainerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetContainerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetContainerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.GetContainerResponse";
  }
  protected:
  explicit GetContainerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
  };
  // .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.GetContainerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class ListContainersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.ListContainersRequest) */ {
 public:
  inline ListContainersRequest() : ListContainersRequest(nullptr) {}
  ~ListContainersRequest() override;
  explicit constexpr ListContainersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListContainersRequest(const ListContainersRequest& from);
  ListContainersRequest(ListContainersRequest&& from) noexcept
    : ListContainersRequest() {
    *this = ::std::move(from);
  }

  inline ListContainersRequest& operator=(const ListContainersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListContainersRequest& operator=(ListContainersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListContainersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListContainersRequest* internal_default_instance() {
    return reinterpret_cast<const ListContainersRequest*>(
               &_ListContainersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListContainersRequest& a, ListContainersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListContainersRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListContainersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListContainersRequest* New() const final {
    return new ListContainersRequest();
  }

  ListContainersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListContainersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListContainersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListContainersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListContainersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.ListContainersRequest";
  }
  protected:
  explicit ListContainersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.ListContainersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class ListContainersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.ListContainersResponse) */ {
 public:
  inline ListContainersResponse() : ListContainersResponse(nullptr) {}
  ~ListContainersResponse() override;
  explicit constexpr ListContainersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListContainersResponse(const ListContainersResponse& from);
  ListContainersResponse(ListContainersResponse&& from) noexcept
    : ListContainersResponse() {
    *this = ::std::move(from);
  }

  inline ListContainersResponse& operator=(const ListContainersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListContainersResponse& operator=(ListContainersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListContainersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListContainersResponse* internal_default_instance() {
    return reinterpret_cast<const ListContainersResponse*>(
               &_ListContainersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListContainersResponse& a, ListContainersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListContainersResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListContainersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListContainersResponse* New() const final {
    return new ListContainersResponse();
  }

  ListContainersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListContainersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListContainersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListContainersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListContainersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.ListContainersResponse";
  }
  protected:
  explicit ListContainersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainersFieldNumber = 1,
  };
  // repeated .containerd.services.containers.v1.Container containers = 1 [(.gogoproto.nullable) = false];
  int containers_size() const;
  private:
  int _internal_containers_size() const;
  public:
  void clear_containers();
  ::containerd::services::containers::v1::Container* mutable_containers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::containers::v1::Container >*
      mutable_containers();
  private:
  const ::containerd::services::containers::v1::Container& _internal_containers(int index) const;
  ::containerd::services::containers::v1::Container* _internal_add_containers();
  public:
  const ::containerd::services::containers::v1::Container& containers(int index) const;
  ::containerd::services::containers::v1::Container* add_containers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::containers::v1::Container >&
      containers() const;

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.ListContainersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::containers::v1::Container > containers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class CreateContainerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.CreateContainerRequest) */ {
 public:
  inline CreateContainerRequest() : CreateContainerRequest(nullptr) {}
  ~CreateContainerRequest() override;
  explicit constexpr CreateContainerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateContainerRequest(const CreateContainerRequest& from);
  CreateContainerRequest(CreateContainerRequest&& from) noexcept
    : CreateContainerRequest() {
    *this = ::std::move(from);
  }

  inline CreateContainerRequest& operator=(const CreateContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateContainerRequest& operator=(CreateContainerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateContainerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateContainerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateContainerRequest*>(
               &_CreateContainerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateContainerRequest& a, CreateContainerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateContainerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateContainerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateContainerRequest* New() const final {
    return new CreateContainerRequest();
  }

  CreateContainerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateContainerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateContainerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateContainerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateContainerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.CreateContainerRequest";
  }
  protected:
  explicit CreateContainerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
  };
  // .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.CreateContainerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class CreateContainerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.CreateContainerResponse) */ {
 public:
  inline CreateContainerResponse() : CreateContainerResponse(nullptr) {}
  ~CreateContainerResponse() override;
  explicit constexpr CreateContainerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateContainerResponse(const CreateContainerResponse& from);
  CreateContainerResponse(CreateContainerResponse&& from) noexcept
    : CreateContainerResponse() {
    *this = ::std::move(from);
  }

  inline CreateContainerResponse& operator=(const CreateContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateContainerResponse& operator=(CreateContainerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateContainerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateContainerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateContainerResponse*>(
               &_CreateContainerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateContainerResponse& a, CreateContainerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateContainerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateContainerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateContainerResponse* New() const final {
    return new CreateContainerResponse();
  }

  CreateContainerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateContainerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateContainerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateContainerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateContainerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.CreateContainerResponse";
  }
  protected:
  explicit CreateContainerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
  };
  // .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.CreateContainerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class UpdateContainerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.UpdateContainerRequest) */ {
 public:
  inline UpdateContainerRequest() : UpdateContainerRequest(nullptr) {}
  ~UpdateContainerRequest() override;
  explicit constexpr UpdateContainerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateContainerRequest(const UpdateContainerRequest& from);
  UpdateContainerRequest(UpdateContainerRequest&& from) noexcept
    : UpdateContainerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateContainerRequest& operator=(const UpdateContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateContainerRequest& operator=(UpdateContainerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateContainerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateContainerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerRequest*>(
               &_UpdateContainerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateContainerRequest& a, UpdateContainerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateContainerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateContainerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateContainerRequest* New() const final {
    return new UpdateContainerRequest();
  }

  UpdateContainerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateContainerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateContainerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateContainerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateContainerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.UpdateContainerRequest";
  }
  protected:
  explicit UpdateContainerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.UpdateContainerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class UpdateContainerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.UpdateContainerResponse) */ {
 public:
  inline UpdateContainerResponse() : UpdateContainerResponse(nullptr) {}
  ~UpdateContainerResponse() override;
  explicit constexpr UpdateContainerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateContainerResponse(const UpdateContainerResponse& from);
  UpdateContainerResponse(UpdateContainerResponse&& from) noexcept
    : UpdateContainerResponse() {
    *this = ::std::move(from);
  }

  inline UpdateContainerResponse& operator=(const UpdateContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateContainerResponse& operator=(UpdateContainerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateContainerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateContainerResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerResponse*>(
               &_UpdateContainerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateContainerResponse& a, UpdateContainerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateContainerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateContainerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateContainerResponse* New() const final {
    return new UpdateContainerResponse();
  }

  UpdateContainerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateContainerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateContainerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateContainerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateContainerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.UpdateContainerResponse";
  }
  protected:
  explicit UpdateContainerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
  };
  // .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.UpdateContainerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class DeleteContainerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.DeleteContainerRequest) */ {
 public:
  inline DeleteContainerRequest() : DeleteContainerRequest(nullptr) {}
  ~DeleteContainerRequest() override;
  explicit constexpr DeleteContainerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteContainerRequest(const DeleteContainerRequest& from);
  DeleteContainerRequest(DeleteContainerRequest&& from) noexcept
    : DeleteContainerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteContainerRequest& operator=(const DeleteContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteContainerRequest& operator=(DeleteContainerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteContainerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteContainerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteContainerRequest*>(
               &_DeleteContainerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteContainerRequest& a, DeleteContainerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteContainerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteContainerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteContainerRequest* New() const final {
    return new DeleteContainerRequest();
  }

  DeleteContainerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteContainerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteContainerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteContainerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteContainerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.DeleteContainerRequest";
  }
  protected:
  explicit DeleteContainerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.DeleteContainerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// -------------------------------------------------------------------

class ListContainerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.containers.v1.ListContainerMessage) */ {
 public:
  inline ListContainerMessage() : ListContainerMessage(nullptr) {}
  ~ListContainerMessage() override;
  explicit constexpr ListContainerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListContainerMessage(const ListContainerMessage& from);
  ListContainerMessage(ListContainerMessage&& from) noexcept
    : ListContainerMessage() {
    *this = ::std::move(from);
  }

  inline ListContainerMessage& operator=(const ListContainerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListContainerMessage& operator=(ListContainerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListContainerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListContainerMessage* internal_default_instance() {
    return reinterpret_cast<const ListContainerMessage*>(
               &_ListContainerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListContainerMessage& a, ListContainerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ListContainerMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListContainerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListContainerMessage* New() const final {
    return new ListContainerMessage();
  }

  ListContainerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListContainerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListContainerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListContainerMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListContainerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.containers.v1.ListContainerMessage";
  }
  protected:
  explicit ListContainerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerFieldNumber = 1,
  };
  // .containerd.services.containers.v1.Container container = 1;
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::containerd::services::containers::v1::Container& container() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::containers::v1::Container* release_container();
  ::containerd::services::containers::v1::Container* mutable_container();
  void set_allocated_container(::containerd::services::containers::v1::Container* container);
  private:
  const ::containerd::services::containers::v1::Container& _internal_container() const;
  ::containerd::services::containers::v1::Container* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::containerd::services::containers::v1::Container* container);
  ::containerd::services::containers::v1::Container* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:containerd.services.containers.v1.ListContainerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::containers::v1::Container* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_containers_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Container_Runtime

// string name = 1;
inline void Container_Runtime::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Container_Runtime::name() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.Runtime.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container_Runtime::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.Container.Runtime.name)
}
inline std::string* Container_Runtime::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.Runtime.name)
  return _s;
}
inline const std::string& Container_Runtime::_internal_name() const {
  return name_.Get();
}
inline void Container_Runtime::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container_Runtime::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container_Runtime::release_name() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.Runtime.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container_Runtime::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.Runtime.name)
}

// .google.protobuf.Any options = 2;
inline bool Container_Runtime::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool Container_Runtime::has_options() const {
  return _internal_has_options();
}
inline const PROTOBUF_NAMESPACE_ID::Any& Container_Runtime::_internal_options() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& Container_Runtime::options() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.Runtime.options)
  return _internal_options();
}
inline void Container_Runtime::unsafe_arena_set_allocated_options(
    PROTOBUF_NAMESPACE_ID::Any* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.Container.Runtime.options)
}
inline PROTOBUF_NAMESPACE_ID::Any* Container_Runtime::release_options() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container_Runtime::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.Runtime.options)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container_Runtime::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container_Runtime::mutable_options() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.Runtime.options)
  return _msg;
}
inline void Container_Runtime::set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.Runtime.options)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Container

// string id = 1;
inline void Container::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Container::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.Container.id)
}
inline std::string* Container::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.id)
  return _s;
}
inline const std::string& Container::_internal_id() const {
  return id_.Get();
}
inline void Container::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.id)
}

// map<string, string> labels = 2;
inline int Container::_internal_labels_size() const {
  return labels_.size();
}
inline int Container::labels_size() const {
  return _internal_labels_size();
}
inline void Container::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Container::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Container::labels() const {
  // @@protoc_insertion_point(field_map:containerd.services.containers.v1.Container.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Container::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Container::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.containers.v1.Container.labels)
  return _internal_mutable_labels();
}

// string image = 3;
inline void Container::clear_image() {
  image_.ClearToEmpty();
}
inline const std::string& Container::image() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container::set_image(ArgT0&& arg0, ArgT... args) {
 
 image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.Container.image)
}
inline std::string* Container::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.image)
  return _s;
}
inline const std::string& Container::_internal_image() const {
  return image_.Get();
}
inline void Container::_internal_set_image(const std::string& value) {
  
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container::_internal_mutable_image() {
  
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container::release_image() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.image)
  return image_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.image)
}

// .containerd.services.containers.v1.Container.Runtime runtime = 4;
inline bool Container::_internal_has_runtime() const {
  return this != internal_default_instance() && runtime_ != nullptr;
}
inline bool Container::has_runtime() const {
  return _internal_has_runtime();
}
inline void Container::clear_runtime() {
  if (GetArenaForAllocation() == nullptr && runtime_ != nullptr) {
    delete runtime_;
  }
  runtime_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container_Runtime& Container::_internal_runtime() const {
  const ::containerd::services::containers::v1::Container_Runtime* p = runtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container_Runtime&>(
      ::containerd::services::containers::v1::_Container_Runtime_default_instance_);
}
inline const ::containerd::services::containers::v1::Container_Runtime& Container::runtime() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.runtime)
  return _internal_runtime();
}
inline void Container::unsafe_arena_set_allocated_runtime(
    ::containerd::services::containers::v1::Container_Runtime* runtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_);
  }
  runtime_ = runtime;
  if (runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.Container.runtime)
}
inline ::containerd::services::containers::v1::Container_Runtime* Container::release_runtime() {
  
  ::containerd::services::containers::v1::Container_Runtime* temp = runtime_;
  runtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container_Runtime* Container::unsafe_arena_release_runtime() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.runtime)
  
  ::containerd::services::containers::v1::Container_Runtime* temp = runtime_;
  runtime_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container_Runtime* Container::_internal_mutable_runtime() {
  
  if (runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container_Runtime>(GetArenaForAllocation());
    runtime_ = p;
  }
  return runtime_;
}
inline ::containerd::services::containers::v1::Container_Runtime* Container::mutable_runtime() {
  ::containerd::services::containers::v1::Container_Runtime* _msg = _internal_mutable_runtime();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.runtime)
  return _msg;
}
inline void Container::set_allocated_runtime(::containerd::services::containers::v1::Container_Runtime* runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete runtime_;
  }
  if (runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container_Runtime>::GetOwningArena(runtime);
    if (message_arena != submessage_arena) {
      runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime, submessage_arena);
    }
    
  } else {
    
  }
  runtime_ = runtime;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.runtime)
}

// .google.protobuf.Any spec = 5;
inline bool Container::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Container::has_spec() const {
  return _internal_has_spec();
}
inline const PROTOBUF_NAMESPACE_ID::Any& Container::_internal_spec() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& Container::spec() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.spec)
  return _internal_spec();
}
inline void Container::unsafe_arena_set_allocated_spec(
    PROTOBUF_NAMESPACE_ID::Any* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.Container.spec)
}
inline PROTOBUF_NAMESPACE_ID::Any* Container::release_spec() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.spec)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline PROTOBUF_NAMESPACE_ID::Any* Container::mutable_spec() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.spec)
  return _msg;
}
inline void Container::set_allocated_spec(PROTOBUF_NAMESPACE_ID::Any* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec));
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.spec)
}

// string snapshotter = 6;
inline void Container::clear_snapshotter() {
  snapshotter_.ClearToEmpty();
}
inline const std::string& Container::snapshotter() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.snapshotter)
  return _internal_snapshotter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container::set_snapshotter(ArgT0&& arg0, ArgT... args) {
 
 snapshotter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.Container.snapshotter)
}
inline std::string* Container::mutable_snapshotter() {
  std::string* _s = _internal_mutable_snapshotter();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.snapshotter)
  return _s;
}
inline const std::string& Container::_internal_snapshotter() const {
  return snapshotter_.Get();
}
inline void Container::_internal_set_snapshotter(const std::string& value) {
  
  snapshotter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container::_internal_mutable_snapshotter() {
  
  return snapshotter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container::release_snapshotter() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.snapshotter)
  return snapshotter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container::set_allocated_snapshotter(std::string* snapshotter) {
  if (snapshotter != nullptr) {
    
  } else {
    
  }
  snapshotter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshotter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.snapshotter)
}

// string snapshot_key = 7;
inline void Container::clear_snapshot_key() {
  snapshot_key_.ClearToEmpty();
}
inline const std::string& Container::snapshot_key() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.snapshot_key)
  return _internal_snapshot_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Container::set_snapshot_key(ArgT0&& arg0, ArgT... args) {
 
 snapshot_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.Container.snapshot_key)
}
inline std::string* Container::mutable_snapshot_key() {
  std::string* _s = _internal_mutable_snapshot_key();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.snapshot_key)
  return _s;
}
inline const std::string& Container::_internal_snapshot_key() const {
  return snapshot_key_.Get();
}
inline void Container::_internal_set_snapshot_key(const std::string& value) {
  
  snapshot_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Container::_internal_mutable_snapshot_key() {
  
  return snapshot_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Container::release_snapshot_key() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.snapshot_key)
  return snapshot_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Container::set_allocated_snapshot_key(std::string* snapshot_key) {
  if (snapshot_key != nullptr) {
    
  } else {
    
  }
  snapshot_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.snapshot_key)
}

// .google.protobuf.Timestamp created_at = 8 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Container::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool Container::has_created_at() const {
  return _internal_has_created_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Container::_internal_created_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Container::created_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.created_at)
  return _internal_created_at();
}
inline void Container::unsafe_arena_set_allocated_created_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.Container.created_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::release_created_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.created_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::mutable_created_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.created_at)
  return _msg;
}
inline void Container::set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.created_at)
}

// .google.protobuf.Timestamp updated_at = 9 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Container::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool Container::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Container::_internal_updated_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Container::updated_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.Container.updated_at)
  return _internal_updated_at();
}
inline void Container::unsafe_arena_set_allocated_updated_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.Container.updated_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::release_updated_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.Container.updated_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Container::mutable_updated_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.Container.updated_at)
  return _msg;
}
inline void Container::set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.Container.updated_at)
}

// map<string, .google.protobuf.Any> extensions = 10 [(.gogoproto.nullable) = false];
inline int Container::_internal_extensions_size() const {
  return extensions_.size();
}
inline int Container::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >&
Container::_internal_extensions() const {
  return extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >&
Container::extensions() const {
  // @@protoc_insertion_point(field_map:containerd.services.containers.v1.Container.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >*
Container::_internal_mutable_extensions() {
  return extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, PROTOBUF_NAMESPACE_ID::Any >*
Container::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.containers.v1.Container.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// GetContainerRequest

// string id = 1;
inline void GetContainerRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetContainerRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.GetContainerRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetContainerRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.GetContainerRequest.id)
}
inline std::string* GetContainerRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.GetContainerRequest.id)
  return _s;
}
inline const std::string& GetContainerRequest::_internal_id() const {
  return id_.Get();
}
inline void GetContainerRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetContainerRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetContainerRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.GetContainerRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetContainerRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.GetContainerRequest.id)
}

// -------------------------------------------------------------------

// GetContainerResponse

// .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
inline bool GetContainerResponse::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool GetContainerResponse::has_container() const {
  return _internal_has_container();
}
inline void GetContainerResponse::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& GetContainerResponse::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& GetContainerResponse::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.GetContainerResponse.container)
  return _internal_container();
}
inline void GetContainerResponse::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.GetContainerResponse.container)
}
inline ::containerd::services::containers::v1::Container* GetContainerResponse::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* GetContainerResponse::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.GetContainerResponse.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* GetContainerResponse::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* GetContainerResponse::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.GetContainerResponse.container)
  return _msg;
}
inline void GetContainerResponse::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.GetContainerResponse.container)
}

// -------------------------------------------------------------------

// ListContainersRequest

// repeated string filters = 1;
inline int ListContainersRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int ListContainersRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListContainersRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* ListContainersRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.containers.v1.ListContainersRequest.filters)
  return _s;
}
inline const std::string& ListContainersRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& ListContainersRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.ListContainersRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListContainersRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.ListContainersRequest.filters)
  return filters_.Mutable(index);
}
inline void ListContainersRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline std::string* ListContainersRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void ListContainersRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline void ListContainersRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.containers.v1.ListContainersRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListContainersRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.containers.v1.ListContainersRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListContainersRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.containers.v1.ListContainersRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// ListContainersResponse

// repeated .containerd.services.containers.v1.Container containers = 1 [(.gogoproto.nullable) = false];
inline int ListContainersResponse::_internal_containers_size() const {
  return containers_.size();
}
inline int ListContainersResponse::containers_size() const {
  return _internal_containers_size();
}
inline void ListContainersResponse::clear_containers() {
  containers_.Clear();
}
inline ::containerd::services::containers::v1::Container* ListContainersResponse::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.ListContainersResponse.containers)
  return containers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::containers::v1::Container >*
ListContainersResponse::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.containers.v1.ListContainersResponse.containers)
  return &containers_;
}
inline const ::containerd::services::containers::v1::Container& ListContainersResponse::_internal_containers(int index) const {
  return containers_.Get(index);
}
inline const ::containerd::services::containers::v1::Container& ListContainersResponse::containers(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.ListContainersResponse.containers)
  return _internal_containers(index);
}
inline ::containerd::services::containers::v1::Container* ListContainersResponse::_internal_add_containers() {
  return containers_.Add();
}
inline ::containerd::services::containers::v1::Container* ListContainersResponse::add_containers() {
  ::containerd::services::containers::v1::Container* _add = _internal_add_containers();
  // @@protoc_insertion_point(field_add:containerd.services.containers.v1.ListContainersResponse.containers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::containers::v1::Container >&
ListContainersResponse::containers() const {
  // @@protoc_insertion_point(field_list:containerd.services.containers.v1.ListContainersResponse.containers)
  return containers_;
}

// -------------------------------------------------------------------

// CreateContainerRequest

// .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
inline bool CreateContainerRequest::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool CreateContainerRequest::has_container() const {
  return _internal_has_container();
}
inline void CreateContainerRequest::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& CreateContainerRequest::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& CreateContainerRequest::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.CreateContainerRequest.container)
  return _internal_container();
}
inline void CreateContainerRequest::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.CreateContainerRequest.container)
}
inline ::containerd::services::containers::v1::Container* CreateContainerRequest::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* CreateContainerRequest::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.CreateContainerRequest.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* CreateContainerRequest::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* CreateContainerRequest::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.CreateContainerRequest.container)
  return _msg;
}
inline void CreateContainerRequest::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.CreateContainerRequest.container)
}

// -------------------------------------------------------------------

// CreateContainerResponse

// .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
inline bool CreateContainerResponse::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool CreateContainerResponse::has_container() const {
  return _internal_has_container();
}
inline void CreateContainerResponse::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& CreateContainerResponse::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& CreateContainerResponse::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.CreateContainerResponse.container)
  return _internal_container();
}
inline void CreateContainerResponse::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.CreateContainerResponse.container)
}
inline ::containerd::services::containers::v1::Container* CreateContainerResponse::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* CreateContainerResponse::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.CreateContainerResponse.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* CreateContainerResponse::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* CreateContainerResponse::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.CreateContainerResponse.container)
  return _msg;
}
inline void CreateContainerResponse::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.CreateContainerResponse.container)
}

// -------------------------------------------------------------------

// UpdateContainerRequest

// .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
inline bool UpdateContainerRequest::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool UpdateContainerRequest::has_container() const {
  return _internal_has_container();
}
inline void UpdateContainerRequest::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& UpdateContainerRequest::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& UpdateContainerRequest::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.UpdateContainerRequest.container)
  return _internal_container();
}
inline void UpdateContainerRequest::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.UpdateContainerRequest.container)
}
inline ::containerd::services::containers::v1::Container* UpdateContainerRequest::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerRequest::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.UpdateContainerRequest.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerRequest::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerRequest::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.UpdateContainerRequest.container)
  return _msg;
}
inline void UpdateContainerRequest::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.UpdateContainerRequest.container)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateContainerRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateContainerRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const PROTOBUF_NAMESPACE_ID::FieldMask& UpdateContainerRequest::_internal_update_mask() const {
  const PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::FieldMask&>(
      PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::FieldMask& UpdateContainerRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.UpdateContainerRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateContainerRequest::unsafe_arena_set_allocated_update_mask(
    PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.UpdateContainerRequest.update_mask)
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContainerRequest::release_update_mask() {
  
  PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContainerRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.UpdateContainerRequest.update_mask)
  
  PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContainerRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContainerRequest::mutable_update_mask() {
  PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.UpdateContainerRequest.update_mask)
  return _msg;
}
inline void UpdateContainerRequest::set_allocated_update_mask(PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.UpdateContainerRequest.update_mask)
}

// -------------------------------------------------------------------

// UpdateContainerResponse

// .containerd.services.containers.v1.Container container = 1 [(.gogoproto.nullable) = false];
inline bool UpdateContainerResponse::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool UpdateContainerResponse::has_container() const {
  return _internal_has_container();
}
inline void UpdateContainerResponse::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& UpdateContainerResponse::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& UpdateContainerResponse::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.UpdateContainerResponse.container)
  return _internal_container();
}
inline void UpdateContainerResponse::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.UpdateContainerResponse.container)
}
inline ::containerd::services::containers::v1::Container* UpdateContainerResponse::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerResponse::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.UpdateContainerResponse.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerResponse::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* UpdateContainerResponse::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.UpdateContainerResponse.container)
  return _msg;
}
inline void UpdateContainerResponse::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.UpdateContainerResponse.container)
}

// -------------------------------------------------------------------

// DeleteContainerRequest

// string id = 1;
inline void DeleteContainerRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteContainerRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.DeleteContainerRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteContainerRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.containers.v1.DeleteContainerRequest.id)
}
inline std::string* DeleteContainerRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.DeleteContainerRequest.id)
  return _s;
}
inline const std::string& DeleteContainerRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteContainerRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteContainerRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteContainerRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.DeleteContainerRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteContainerRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.DeleteContainerRequest.id)
}

// -------------------------------------------------------------------

// ListContainerMessage

// .containerd.services.containers.v1.Container container = 1;
inline bool ListContainerMessage::_internal_has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline bool ListContainerMessage::has_container() const {
  return _internal_has_container();
}
inline void ListContainerMessage::clear_container() {
  if (GetArenaForAllocation() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::containerd::services::containers::v1::Container& ListContainerMessage::_internal_container() const {
  const ::containerd::services::containers::v1::Container* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::containers::v1::Container&>(
      ::containerd::services::containers::v1::_Container_default_instance_);
}
inline const ::containerd::services::containers::v1::Container& ListContainerMessage::container() const {
  // @@protoc_insertion_point(field_get:containerd.services.containers.v1.ListContainerMessage.container)
  return _internal_container();
}
inline void ListContainerMessage::unsafe_arena_set_allocated_container(
    ::containerd::services::containers::v1::Container* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.containers.v1.ListContainerMessage.container)
}
inline ::containerd::services::containers::v1::Container* ListContainerMessage::release_container() {
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::containers::v1::Container* ListContainerMessage::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:containerd.services.containers.v1.ListContainerMessage.container)
  
  ::containerd::services::containers::v1::Container* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::containerd::services::containers::v1::Container* ListContainerMessage::_internal_mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::containers::v1::Container>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::containerd::services::containers::v1::Container* ListContainerMessage::mutable_container() {
  ::containerd::services::containers::v1::Container* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:containerd.services.containers.v1.ListContainerMessage.container)
  return _msg;
}
inline void ListContainerMessage::set_allocated_container(::containerd::services::containers::v1::Container* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::containers::v1::Container>::GetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.containers.v1.ListContainerMessage.container)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace containers
}  // namespace services
}  // namespace containerd

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_containers_2eproto
