// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: introspection.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_introspection_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_introspection_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "platform.pb.h"
#include "status.pb.h"
#include <google/protobuf/empty.pb.h>
#include "gogo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_introspection_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_introspection_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_introspection_2eproto;
namespace containerd {
namespace services {
namespace introspection {
namespace v1 {
class Plugin;
struct PluginDefaultTypeInternal;
extern PluginDefaultTypeInternal _Plugin_default_instance_;
class Plugin_ExportsEntry_DoNotUse;
struct Plugin_ExportsEntry_DoNotUseDefaultTypeInternal;
extern Plugin_ExportsEntry_DoNotUseDefaultTypeInternal _Plugin_ExportsEntry_DoNotUse_default_instance_;
class PluginsRequest;
struct PluginsRequestDefaultTypeInternal;
extern PluginsRequestDefaultTypeInternal _PluginsRequest_default_instance_;
class PluginsResponse;
struct PluginsResponseDefaultTypeInternal;
extern PluginsResponseDefaultTypeInternal _PluginsResponse_default_instance_;
class ServerResponse;
struct ServerResponseDefaultTypeInternal;
extern ServerResponseDefaultTypeInternal _ServerResponse_default_instance_;
}  // namespace v1
}  // namespace introspection
}  // namespace services
}  // namespace containerd
PROTOBUF_NAMESPACE_OPEN
template<> ::containerd::services::introspection::v1::Plugin* Arena::CreateMaybeMessage<::containerd::services::introspection::v1::Plugin>(Arena*);
template<> ::containerd::services::introspection::v1::Plugin_ExportsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::introspection::v1::Plugin_ExportsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::introspection::v1::PluginsRequest* Arena::CreateMaybeMessage<::containerd::services::introspection::v1::PluginsRequest>(Arena*);
template<> ::containerd::services::introspection::v1::PluginsResponse* Arena::CreateMaybeMessage<::containerd::services::introspection::v1::PluginsResponse>(Arena*);
template<> ::containerd::services::introspection::v1::ServerResponse* Arena::CreateMaybeMessage<::containerd::services::introspection::v1::ServerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace containerd {
namespace services {
namespace introspection {
namespace v1 {

// ===================================================================

class Plugin_ExportsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Plugin_ExportsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Plugin_ExportsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Plugin_ExportsEntry_DoNotUse();
  explicit constexpr Plugin_ExportsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Plugin_ExportsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Plugin_ExportsEntry_DoNotUse& other);
  static const Plugin_ExportsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Plugin_ExportsEntry_DoNotUse*>(&_Plugin_ExportsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.introspection.v1.Plugin.ExportsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.introspection.v1.Plugin.ExportsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Plugin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.introspection.v1.Plugin) */ {
 public:
  inline Plugin() : Plugin(nullptr) {}
  ~Plugin() override;
  explicit constexpr Plugin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plugin(const Plugin& from);
  Plugin(Plugin&& from) noexcept
    : Plugin() {
    *this = ::std::move(from);
  }

  inline Plugin& operator=(const Plugin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plugin& operator=(Plugin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plugin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plugin* internal_default_instance() {
    return reinterpret_cast<const Plugin*>(
               &_Plugin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Plugin& a, Plugin& b) {
    a.Swap(&b);
  }
  inline void Swap(Plugin* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plugin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plugin* New() const final {
    return new Plugin();
  }

  Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plugin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plugin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Plugin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plugin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.introspection.v1.Plugin";
  }
  protected:
  explicit Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRequiresFieldNumber = 3,
    kPlatformsFieldNumber = 4,
    kExportsFieldNumber = 5,
    kCapabilitiesFieldNumber = 6,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kInitErrFieldNumber = 7,
  };
  // repeated string requires = 3;
  int requires_size() const;
  private:
  int _internal_requires_size() const;
  public:
  void clear_requires();
  const std::string& requires(int index) const;
  std::string* mutable_requires(int index);
  void set_requires(int index, const std::string& value);
  void set_requires(int index, std::string&& value);
  void set_requires(int index, const char* value);
  void set_requires(int index, const char* value, size_t size);
  std::string* add_requires();
  void add_requires(const std::string& value);
  void add_requires(std::string&& value);
  void add_requires(const char* value);
  void add_requires(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requires() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requires();
  private:
  const std::string& _internal_requires(int index) const;
  std::string* _internal_add_requires();
  public:

  // repeated .containerd.types.Platform platforms = 4 [(.gogoproto.nullable) = false];
  int platforms_size() const;
  private:
  int _internal_platforms_size() const;
  public:
  void clear_platforms();
  ::containerd::types::Platform* mutable_platforms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Platform >*
      mutable_platforms();
  private:
  const ::containerd::types::Platform& _internal_platforms(int index) const;
  ::containerd::types::Platform* _internal_add_platforms();
  public:
  const ::containerd::types::Platform& platforms(int index) const;
  ::containerd::types::Platform* add_platforms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Platform >&
      platforms() const;

  // map<string, string> exports = 5;
  int exports_size() const;
  private:
  int _internal_exports_size() const;
  public:
  void clear_exports();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_exports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_exports();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      exports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_exports();

  // repeated string capabilities = 6;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const std::string& value);
  void set_capabilities(int index, std::string&& value);
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  std::string* add_capabilities();
  void add_capabilities(const std::string& value);
  void add_capabilities(std::string&& value);
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_capabilities();
  private:
  const std::string& _internal_capabilities(int index) const;
  std::string* _internal_add_capabilities();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.rpc.Status init_err = 7;
  bool has_init_err() const;
  private:
  bool _internal_has_init_err() const;
  public:
  void clear_init_err();
  const ::google::rpc::Status& init_err() const;
  PROTOBUF_MUST_USE_RESULT ::google::rpc::Status* release_init_err();
  ::google::rpc::Status* mutable_init_err();
  void set_allocated_init_err(::google::rpc::Status* init_err);
  private:
  const ::google::rpc::Status& _internal_init_err() const;
  ::google::rpc::Status* _internal_mutable_init_err();
  public:
  void unsafe_arena_set_allocated_init_err(
      ::google::rpc::Status* init_err);
  ::google::rpc::Status* unsafe_arena_release_init_err();

  // @@protoc_insertion_point(class_scope:containerd.services.introspection.v1.Plugin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requires_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Platform > platforms_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Plugin_ExportsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> exports_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::google::rpc::Status* init_err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_introspection_2eproto;
};
// -------------------------------------------------------------------

class PluginsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.introspection.v1.PluginsRequest) */ {
 public:
  inline PluginsRequest() : PluginsRequest(nullptr) {}
  ~PluginsRequest() override;
  explicit constexpr PluginsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginsRequest(const PluginsRequest& from);
  PluginsRequest(PluginsRequest&& from) noexcept
    : PluginsRequest() {
    *this = ::std::move(from);
  }

  inline PluginsRequest& operator=(const PluginsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginsRequest& operator=(PluginsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginsRequest* internal_default_instance() {
    return reinterpret_cast<const PluginsRequest*>(
               &_PluginsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PluginsRequest& a, PluginsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginsRequest* New() const final {
    return new PluginsRequest();
  }

  PluginsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.introspection.v1.PluginsRequest";
  }
  protected:
  explicit PluginsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.introspection.v1.PluginsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_introspection_2eproto;
};
// -------------------------------------------------------------------

class PluginsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.introspection.v1.PluginsResponse) */ {
 public:
  inline PluginsResponse() : PluginsResponse(nullptr) {}
  ~PluginsResponse() override;
  explicit constexpr PluginsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PluginsResponse(const PluginsResponse& from);
  PluginsResponse(PluginsResponse&& from) noexcept
    : PluginsResponse() {
    *this = ::std::move(from);
  }

  inline PluginsResponse& operator=(const PluginsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginsResponse& operator=(PluginsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginsResponse* internal_default_instance() {
    return reinterpret_cast<const PluginsResponse*>(
               &_PluginsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PluginsResponse& a, PluginsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginsResponse* New() const final {
    return new PluginsResponse();
  }

  PluginsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PluginsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PluginsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.introspection.v1.PluginsResponse";
  }
  protected:
  explicit PluginsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginsFieldNumber = 1,
  };
  // repeated .containerd.services.introspection.v1.Plugin plugins = 1 [(.gogoproto.nullable) = false];
  int plugins_size() const;
  private:
  int _internal_plugins_size() const;
  public:
  void clear_plugins();
  ::containerd::services::introspection::v1::Plugin* mutable_plugins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::introspection::v1::Plugin >*
      mutable_plugins();
  private:
  const ::containerd::services::introspection::v1::Plugin& _internal_plugins(int index) const;
  ::containerd::services::introspection::v1::Plugin* _internal_add_plugins();
  public:
  const ::containerd::services::introspection::v1::Plugin& plugins(int index) const;
  ::containerd::services::introspection::v1::Plugin* add_plugins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::introspection::v1::Plugin >&
      plugins() const;

  // @@protoc_insertion_point(class_scope:containerd.services.introspection.v1.PluginsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::introspection::v1::Plugin > plugins_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_introspection_2eproto;
};
// -------------------------------------------------------------------

class ServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.introspection.v1.ServerResponse) */ {
 public:
  inline ServerResponse() : ServerResponse(nullptr) {}
  ~ServerResponse() override;
  explicit constexpr ServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerResponse(const ServerResponse& from);
  ServerResponse(ServerResponse&& from) noexcept
    : ServerResponse() {
    *this = ::std::move(from);
  }

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerResponse& operator=(ServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerResponse* internal_default_instance() {
    return reinterpret_cast<const ServerResponse*>(
               &_ServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerResponse& a, ServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerResponse* New() const final {
    return new ServerResponse();
  }

  ServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.introspection.v1.ServerResponse";
  }
  protected:
  explicit ServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
  };
  // string uuid = 1 [(.gogoproto.customname) = "UUID"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.introspection.v1.ServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_introspection_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Plugin

// string type = 1;
inline void Plugin::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Plugin::type() const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.type)
}
inline std::string* Plugin::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.type)
  return _s;
}
inline const std::string& Plugin::_internal_type() const {
  return type_.Get();
}
inline void Plugin::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Plugin::release_type() {
  // @@protoc_insertion_point(field_release:containerd.services.introspection.v1.Plugin.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Plugin::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.introspection.v1.Plugin.type)
}

// string id = 2;
inline void Plugin::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Plugin::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Plugin::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.id)
}
inline std::string* Plugin::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.id)
  return _s;
}
inline const std::string& Plugin::_internal_id() const {
  return id_.Get();
}
inline void Plugin::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Plugin::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Plugin::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.introspection.v1.Plugin.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Plugin::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.introspection.v1.Plugin.id)
}

// repeated string requires = 3;
inline int Plugin::_internal_requires_size() const {
  return requires_.size();
}
inline int Plugin::requires_size() const {
  return _internal_requires_size();
}
inline void Plugin::clear_requires() {
  requires_.Clear();
}
inline std::string* Plugin::add_requires() {
  std::string* _s = _internal_add_requires();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.introspection.v1.Plugin.requires)
  return _s;
}
inline const std::string& Plugin::_internal_requires(int index) const {
  return requires_.Get(index);
}
inline const std::string& Plugin::requires(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.requires)
  return _internal_requires(index);
}
inline std::string* Plugin::mutable_requires(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.requires)
  return requires_.Mutable(index);
}
inline void Plugin::set_requires(int index, const std::string& value) {
  requires_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::set_requires(int index, std::string&& value) {
  requires_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::set_requires(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requires_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::set_requires(int index, const char* value, size_t size) {
  requires_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.introspection.v1.Plugin.requires)
}
inline std::string* Plugin::_internal_add_requires() {
  return requires_.Add();
}
inline void Plugin::add_requires(const std::string& value) {
  requires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::add_requires(std::string&& value) {
  requires_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::add_requires(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requires_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.introspection.v1.Plugin.requires)
}
inline void Plugin::add_requires(const char* value, size_t size) {
  requires_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.introspection.v1.Plugin.requires)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Plugin::requires() const {
  // @@protoc_insertion_point(field_list:containerd.services.introspection.v1.Plugin.requires)
  return requires_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Plugin::mutable_requires() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.introspection.v1.Plugin.requires)
  return &requires_;
}

// repeated .containerd.types.Platform platforms = 4 [(.gogoproto.nullable) = false];
inline int Plugin::_internal_platforms_size() const {
  return platforms_.size();
}
inline int Plugin::platforms_size() const {
  return _internal_platforms_size();
}
inline ::containerd::types::Platform* Plugin::mutable_platforms(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.platforms)
  return platforms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Platform >*
Plugin::mutable_platforms() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.introspection.v1.Plugin.platforms)
  return &platforms_;
}
inline const ::containerd::types::Platform& Plugin::_internal_platforms(int index) const {
  return platforms_.Get(index);
}
inline const ::containerd::types::Platform& Plugin::platforms(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.platforms)
  return _internal_platforms(index);
}
inline ::containerd::types::Platform* Plugin::_internal_add_platforms() {
  return platforms_.Add();
}
inline ::containerd::types::Platform* Plugin::add_platforms() {
  ::containerd::types::Platform* _add = _internal_add_platforms();
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.Plugin.platforms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Platform >&
Plugin::platforms() const {
  // @@protoc_insertion_point(field_list:containerd.services.introspection.v1.Plugin.platforms)
  return platforms_;
}

// map<string, string> exports = 5;
inline int Plugin::_internal_exports_size() const {
  return exports_.size();
}
inline int Plugin::exports_size() const {
  return _internal_exports_size();
}
inline void Plugin::clear_exports() {
  exports_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Plugin::_internal_exports() const {
  return exports_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Plugin::exports() const {
  // @@protoc_insertion_point(field_map:containerd.services.introspection.v1.Plugin.exports)
  return _internal_exports();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Plugin::_internal_mutable_exports() {
  return exports_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Plugin::mutable_exports() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.introspection.v1.Plugin.exports)
  return _internal_mutable_exports();
}

// repeated string capabilities = 6;
inline int Plugin::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int Plugin::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void Plugin::clear_capabilities() {
  capabilities_.Clear();
}
inline std::string* Plugin::add_capabilities() {
  std::string* _s = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.introspection.v1.Plugin.capabilities)
  return _s;
}
inline const std::string& Plugin::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const std::string& Plugin::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.capabilities)
  return _internal_capabilities(index);
}
inline std::string* Plugin::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.capabilities)
  return capabilities_.Mutable(index);
}
inline void Plugin::set_capabilities(int index, const std::string& value) {
  capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::set_capabilities(int index, std::string&& value) {
  capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::set_capabilities(int index, const char* value, size_t size) {
  capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.introspection.v1.Plugin.capabilities)
}
inline std::string* Plugin::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline void Plugin::add_capabilities(const std::string& value) {
  capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::add_capabilities(std::string&& value) {
  capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.introspection.v1.Plugin.capabilities)
}
inline void Plugin::add_capabilities(const char* value, size_t size) {
  capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.introspection.v1.Plugin.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Plugin::capabilities() const {
  // @@protoc_insertion_point(field_list:containerd.services.introspection.v1.Plugin.capabilities)
  return capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Plugin::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.introspection.v1.Plugin.capabilities)
  return &capabilities_;
}

// .google.rpc.Status init_err = 7;
inline bool Plugin::_internal_has_init_err() const {
  return this != internal_default_instance() && init_err_ != nullptr;
}
inline bool Plugin::has_init_err() const {
  return _internal_has_init_err();
}
inline const ::google::rpc::Status& Plugin::_internal_init_err() const {
  const ::google::rpc::Status* p = init_err_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& Plugin::init_err() const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.Plugin.init_err)
  return _internal_init_err();
}
inline void Plugin::unsafe_arena_set_allocated_init_err(
    ::google::rpc::Status* init_err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(init_err_);
  }
  init_err_ = init_err;
  if (init_err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.introspection.v1.Plugin.init_err)
}
inline ::google::rpc::Status* Plugin::release_init_err() {
  
  ::google::rpc::Status* temp = init_err_;
  init_err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* Plugin::unsafe_arena_release_init_err() {
  // @@protoc_insertion_point(field_release:containerd.services.introspection.v1.Plugin.init_err)
  
  ::google::rpc::Status* temp = init_err_;
  init_err_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* Plugin::_internal_mutable_init_err() {
  
  if (init_err_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    init_err_ = p;
  }
  return init_err_;
}
inline ::google::rpc::Status* Plugin::mutable_init_err() {
  ::google::rpc::Status* _msg = _internal_mutable_init_err();
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.Plugin.init_err)
  return _msg;
}
inline void Plugin::set_allocated_init_err(::google::rpc::Status* init_err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(init_err_);
  }
  if (init_err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(init_err));
    if (message_arena != submessage_arena) {
      init_err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_err, submessage_arena);
    }
    
  } else {
    
  }
  init_err_ = init_err;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.introspection.v1.Plugin.init_err)
}

// -------------------------------------------------------------------

// PluginsRequest

// repeated string filters = 1;
inline int PluginsRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int PluginsRequest::filters_size() const {
  return _internal_filters_size();
}
inline void PluginsRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* PluginsRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.introspection.v1.PluginsRequest.filters)
  return _s;
}
inline const std::string& PluginsRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& PluginsRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.PluginsRequest.filters)
  return _internal_filters(index);
}
inline std::string* PluginsRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.PluginsRequest.filters)
  return filters_.Mutable(index);
}
inline void PluginsRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline std::string* PluginsRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void PluginsRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline void PluginsRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.introspection.v1.PluginsRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PluginsRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.introspection.v1.PluginsRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PluginsRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.introspection.v1.PluginsRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// PluginsResponse

// repeated .containerd.services.introspection.v1.Plugin plugins = 1 [(.gogoproto.nullable) = false];
inline int PluginsResponse::_internal_plugins_size() const {
  return plugins_.size();
}
inline int PluginsResponse::plugins_size() const {
  return _internal_plugins_size();
}
inline void PluginsResponse::clear_plugins() {
  plugins_.Clear();
}
inline ::containerd::services::introspection::v1::Plugin* PluginsResponse::mutable_plugins(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.PluginsResponse.plugins)
  return plugins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::introspection::v1::Plugin >*
PluginsResponse::mutable_plugins() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.introspection.v1.PluginsResponse.plugins)
  return &plugins_;
}
inline const ::containerd::services::introspection::v1::Plugin& PluginsResponse::_internal_plugins(int index) const {
  return plugins_.Get(index);
}
inline const ::containerd::services::introspection::v1::Plugin& PluginsResponse::plugins(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.PluginsResponse.plugins)
  return _internal_plugins(index);
}
inline ::containerd::services::introspection::v1::Plugin* PluginsResponse::_internal_add_plugins() {
  return plugins_.Add();
}
inline ::containerd::services::introspection::v1::Plugin* PluginsResponse::add_plugins() {
  ::containerd::services::introspection::v1::Plugin* _add = _internal_add_plugins();
  // @@protoc_insertion_point(field_add:containerd.services.introspection.v1.PluginsResponse.plugins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::introspection::v1::Plugin >&
PluginsResponse::plugins() const {
  // @@protoc_insertion_point(field_list:containerd.services.introspection.v1.PluginsResponse.plugins)
  return plugins_;
}

// -------------------------------------------------------------------

// ServerResponse

// string uuid = 1 [(.gogoproto.customname) = "UUID"];
inline void ServerResponse::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& ServerResponse::uuid() const {
  // @@protoc_insertion_point(field_get:containerd.services.introspection.v1.ServerResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.introspection.v1.ServerResponse.uuid)
}
inline std::string* ServerResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:containerd.services.introspection.v1.ServerResponse.uuid)
  return _s;
}
inline const std::string& ServerResponse::_internal_uuid() const {
  return uuid_.Get();
}
inline void ServerResponse::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerResponse::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:containerd.services.introspection.v1.ServerResponse.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.introspection.v1.ServerResponse.uuid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace introspection
}  // namespace services
}  // namespace containerd

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_introspection_2eproto
