// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: leases.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_leases_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_leases_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogo.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_leases_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_leases_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_leases_2eproto;
namespace containerd {
namespace services {
namespace leases {
namespace v1 {
class AddResourceRequest;
struct AddResourceRequestDefaultTypeInternal;
extern AddResourceRequestDefaultTypeInternal _AddResourceRequest_default_instance_;
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateRequest_LabelsEntry_DoNotUse;
struct CreateRequest_LabelsEntry_DoNotUseDefaultTypeInternal;
extern CreateRequest_LabelsEntry_DoNotUseDefaultTypeInternal _CreateRequest_LabelsEntry_DoNotUse_default_instance_;
class CreateResponse;
struct CreateResponseDefaultTypeInternal;
extern CreateResponseDefaultTypeInternal _CreateResponse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResourceRequest;
struct DeleteResourceRequestDefaultTypeInternal;
extern DeleteResourceRequestDefaultTypeInternal _DeleteResourceRequest_default_instance_;
class Lease;
struct LeaseDefaultTypeInternal;
extern LeaseDefaultTypeInternal _Lease_default_instance_;
class Lease_LabelsEntry_DoNotUse;
struct Lease_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Lease_LabelsEntry_DoNotUseDefaultTypeInternal _Lease_LabelsEntry_DoNotUse_default_instance_;
class ListRequest;
struct ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class ListResourcesRequest;
struct ListResourcesRequestDefaultTypeInternal;
extern ListResourcesRequestDefaultTypeInternal _ListResourcesRequest_default_instance_;
class ListResourcesResponse;
struct ListResourcesResponseDefaultTypeInternal;
extern ListResourcesResponseDefaultTypeInternal _ListResourcesResponse_default_instance_;
class ListResponse;
struct ListResponseDefaultTypeInternal;
extern ListResponseDefaultTypeInternal _ListResponse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
}  // namespace v1
}  // namespace leases
}  // namespace services
}  // namespace containerd
PROTOBUF_NAMESPACE_OPEN
template<> ::containerd::services::leases::v1::AddResourceRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::AddResourceRequest>(Arena*);
template<> ::containerd::services::leases::v1::CreateRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::CreateRequest>(Arena*);
template<> ::containerd::services::leases::v1::CreateRequest_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::leases::v1::CreateRequest_LabelsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::leases::v1::CreateResponse* Arena::CreateMaybeMessage<::containerd::services::leases::v1::CreateResponse>(Arena*);
template<> ::containerd::services::leases::v1::DeleteRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::DeleteRequest>(Arena*);
template<> ::containerd::services::leases::v1::DeleteResourceRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::DeleteResourceRequest>(Arena*);
template<> ::containerd::services::leases::v1::Lease* Arena::CreateMaybeMessage<::containerd::services::leases::v1::Lease>(Arena*);
template<> ::containerd::services::leases::v1::Lease_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::leases::v1::Lease_LabelsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::leases::v1::ListRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::ListRequest>(Arena*);
template<> ::containerd::services::leases::v1::ListResourcesRequest* Arena::CreateMaybeMessage<::containerd::services::leases::v1::ListResourcesRequest>(Arena*);
template<> ::containerd::services::leases::v1::ListResourcesResponse* Arena::CreateMaybeMessage<::containerd::services::leases::v1::ListResourcesResponse>(Arena*);
template<> ::containerd::services::leases::v1::ListResponse* Arena::CreateMaybeMessage<::containerd::services::leases::v1::ListResponse>(Arena*);
template<> ::containerd::services::leases::v1::Resource* Arena::CreateMaybeMessage<::containerd::services::leases::v1::Resource>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace containerd {
namespace services {
namespace leases {
namespace v1 {

// ===================================================================

class Lease_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Lease_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Lease_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Lease_LabelsEntry_DoNotUse();
  explicit constexpr Lease_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Lease_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Lease_LabelsEntry_DoNotUse& other);
  static const Lease_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lease_LabelsEntry_DoNotUse*>(&_Lease_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.leases.v1.Lease.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.leases.v1.Lease.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Lease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.Lease) */ {
 public:
  inline Lease() : Lease(nullptr) {}
  ~Lease() override;
  explicit constexpr Lease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lease(const Lease& from);
  Lease(Lease&& from) noexcept
    : Lease() {
    *this = ::std::move(from);
  }

  inline Lease& operator=(const Lease& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lease& operator=(Lease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lease& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lease* internal_default_instance() {
    return reinterpret_cast<const Lease*>(
               &_Lease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Lease& a, Lease& b) {
    a.Swap(&b);
  }
  inline void Swap(Lease* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lease* New() const final {
    return new Lease();
  }

  Lease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Lease& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lease* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.Lease";
  }
  protected:
  explicit Lease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 3,
    kIdFieldNumber = 1,
    kCreatedAtFieldNumber = 2,
  };
  // map<string, string> labels = 3;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Timestamp created_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.Lease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Lease_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateRequest_LabelsEntry_DoNotUse();
  explicit constexpr CreateRequest_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateRequest_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateRequest_LabelsEntry_DoNotUse& other);
  static const CreateRequest_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateRequest_LabelsEntry_DoNotUse*>(&_CreateRequest_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.leases.v1.CreateRequest.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.leases.v1.CreateRequest.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit constexpr CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRequest* New() const final {
    return new CreateRequest();
  }

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // map<string, string> labels = 3;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateRequest_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class CreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.CreateResponse) */ {
 public:
  inline CreateResponse() : CreateResponse(nullptr) {}
  ~CreateResponse() override;
  explicit constexpr CreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateResponse(const CreateResponse& from);
  CreateResponse(CreateResponse&& from) noexcept
    : CreateResponse() {
    *this = ::std::move(from);
  }

  inline CreateResponse& operator=(const CreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateResponse& operator=(CreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateResponse* internal_default_instance() {
    return reinterpret_cast<const CreateResponse*>(
               &_CreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateResponse& a, CreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateResponse* New() const final {
    return new CreateResponse();
  }

  CreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.CreateResponse";
  }
  protected:
  explicit CreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseFieldNumber = 1,
  };
  // .containerd.services.leases.v1.Lease lease = 1;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::containerd::services::leases::v1::Lease& lease() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::leases::v1::Lease* release_lease();
  ::containerd::services::leases::v1::Lease* mutable_lease();
  void set_allocated_lease(::containerd::services::leases::v1::Lease* lease);
  private:
  const ::containerd::services::leases::v1::Lease& _internal_lease() const;
  ::containerd::services::leases::v1::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::containerd::services::leases::v1::Lease* lease);
  ::containerd::services::leases::v1::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.CreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::leases::v1::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return new DeleteRequest();
  }

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSyncFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool sync = 2;
  void clear_sync();
  bool sync() const;
  void set_sync(bool value);
  private:
  bool _internal_sync() const;
  void _internal_set_sync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool sync_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class ListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  ~ListRequest() override;
  explicit constexpr ListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRequest* New() const final {
    return new ListRequest();
  }

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class ListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.ListResponse) */ {
 public:
  inline ListResponse() : ListResponse(nullptr) {}
  ~ListResponse() override;
  explicit constexpr ListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResponse(const ListResponse& from);
  ListResponse(ListResponse&& from) noexcept
    : ListResponse() {
    *this = ::std::move(from);
  }

  inline ListResponse& operator=(const ListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponse& operator=(ListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResponse* internal_default_instance() {
    return reinterpret_cast<const ListResponse*>(
               &_ListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListResponse& a, ListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListResponse* New() const final {
    return new ListResponse();
  }

  ListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.ListResponse";
  }
  protected:
  explicit ListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 1,
  };
  // repeated .containerd.services.leases.v1.Lease leases = 1;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::containerd::services::leases::v1::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Lease >*
      mutable_leases();
  private:
  const ::containerd::services::leases::v1::Lease& _internal_leases(int index) const;
  ::containerd::services::leases::v1::Lease* _internal_add_leases();
  public:
  const ::containerd::services::leases::v1::Lease& leases(int index) const;
  ::containerd::services::leases::v1::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Lease >&
      leases() const;

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.ListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Lease > leases_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit constexpr Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const final {
    return new Resource();
  }

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Resource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class AddResourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.AddResourceRequest) */ {
 public:
  inline AddResourceRequest() : AddResourceRequest(nullptr) {}
  ~AddResourceRequest() override;
  explicit constexpr AddResourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddResourceRequest(const AddResourceRequest& from);
  AddResourceRequest(AddResourceRequest&& from) noexcept
    : AddResourceRequest() {
    *this = ::std::move(from);
  }

  inline AddResourceRequest& operator=(const AddResourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddResourceRequest& operator=(AddResourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddResourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddResourceRequest* internal_default_instance() {
    return reinterpret_cast<const AddResourceRequest*>(
               &_AddResourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddResourceRequest& a, AddResourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddResourceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddResourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddResourceRequest* New() const final {
    return new AddResourceRequest();
  }

  AddResourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddResourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddResourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddResourceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddResourceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.AddResourceRequest";
  }
  protected:
  explicit AddResourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .containerd.services.leases.v1.Resource resource = 2 [(.gogoproto.nullable) = false];
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::containerd::services::leases::v1::Resource& resource() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::leases::v1::Resource* release_resource();
  ::containerd::services::leases::v1::Resource* mutable_resource();
  void set_allocated_resource(::containerd::services::leases::v1::Resource* resource);
  private:
  const ::containerd::services::leases::v1::Resource& _internal_resource() const;
  ::containerd::services::leases::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::containerd::services::leases::v1::Resource* resource);
  ::containerd::services::leases::v1::Resource* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.AddResourceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::containerd::services::leases::v1::Resource* resource_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class DeleteResourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.DeleteResourceRequest) */ {
 public:
  inline DeleteResourceRequest() : DeleteResourceRequest(nullptr) {}
  ~DeleteResourceRequest() override;
  explicit constexpr DeleteResourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResourceRequest(const DeleteResourceRequest& from);
  DeleteResourceRequest(DeleteResourceRequest&& from) noexcept
    : DeleteResourceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteResourceRequest& operator=(const DeleteResourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResourceRequest& operator=(DeleteResourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResourceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteResourceRequest*>(
               &_DeleteResourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteResourceRequest& a, DeleteResourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResourceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteResourceRequest* New() const final {
    return new DeleteResourceRequest();
  }

  DeleteResourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteResourceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResourceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.DeleteResourceRequest";
  }
  protected:
  explicit DeleteResourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .containerd.services.leases.v1.Resource resource = 2 [(.gogoproto.nullable) = false];
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::containerd::services::leases::v1::Resource& resource() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::leases::v1::Resource* release_resource();
  ::containerd::services::leases::v1::Resource* mutable_resource();
  void set_allocated_resource(::containerd::services::leases::v1::Resource* resource);
  private:
  const ::containerd::services::leases::v1::Resource& _internal_resource() const;
  ::containerd::services::leases::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::containerd::services::leases::v1::Resource* resource);
  ::containerd::services::leases::v1::Resource* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.DeleteResourceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::containerd::services::leases::v1::Resource* resource_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class ListResourcesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.ListResourcesRequest) */ {
 public:
  inline ListResourcesRequest() : ListResourcesRequest(nullptr) {}
  ~ListResourcesRequest() override;
  explicit constexpr ListResourcesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResourcesRequest(const ListResourcesRequest& from);
  ListResourcesRequest(ListResourcesRequest&& from) noexcept
    : ListResourcesRequest() {
    *this = ::std::move(from);
  }

  inline ListResourcesRequest& operator=(const ListResourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResourcesRequest& operator=(ListResourcesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResourcesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResourcesRequest* internal_default_instance() {
    return reinterpret_cast<const ListResourcesRequest*>(
               &_ListResourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListResourcesRequest& a, ListResourcesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResourcesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResourcesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListResourcesRequest* New() const final {
    return new ListResourcesRequest();
  }

  ListResourcesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListResourcesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResourcesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListResourcesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.ListResourcesRequest";
  }
  protected:
  explicit ListResourcesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.ListResourcesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// -------------------------------------------------------------------

class ListResourcesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.leases.v1.ListResourcesResponse) */ {
 public:
  inline ListResourcesResponse() : ListResourcesResponse(nullptr) {}
  ~ListResourcesResponse() override;
  explicit constexpr ListResourcesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResourcesResponse(const ListResourcesResponse& from);
  ListResourcesResponse(ListResourcesResponse&& from) noexcept
    : ListResourcesResponse() {
    *this = ::std::move(from);
  }

  inline ListResourcesResponse& operator=(const ListResourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResourcesResponse& operator=(ListResourcesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResourcesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResourcesResponse* internal_default_instance() {
    return reinterpret_cast<const ListResourcesResponse*>(
               &_ListResourcesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListResourcesResponse& a, ListResourcesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResourcesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResourcesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListResourcesResponse* New() const final {
    return new ListResourcesResponse();
  }

  ListResourcesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListResourcesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResourcesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListResourcesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResourcesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.leases.v1.ListResourcesResponse";
  }
  protected:
  explicit ListResourcesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 1,
  };
  // repeated .containerd.services.leases.v1.Resource resources = 1 [(.gogoproto.nullable) = false];
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::containerd::services::leases::v1::Resource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Resource >*
      mutable_resources();
  private:
  const ::containerd::services::leases::v1::Resource& _internal_resources(int index) const;
  ::containerd::services::leases::v1::Resource* _internal_add_resources();
  public:
  const ::containerd::services::leases::v1::Resource& resources(int index) const;
  ::containerd::services::leases::v1::Resource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:containerd.services.leases.v1.ListResourcesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Resource > resources_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_leases_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Lease

// string id = 1;
inline void Lease::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Lease::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.Lease.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lease::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.Lease.id)
}
inline std::string* Lease::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.Lease.id)
  return _s;
}
inline const std::string& Lease::_internal_id() const {
  return id_.Get();
}
inline void Lease::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Lease::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Lease::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.Lease.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Lease::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.Lease.id)
}

// .google.protobuf.Timestamp created_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Lease::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool Lease::has_created_at() const {
  return _internal_has_created_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lease::_internal_created_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Lease::created_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.Lease.created_at)
  return _internal_created_at();
}
inline void Lease::unsafe_arena_set_allocated_created_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.leases.v1.Lease.created_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lease::release_created_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lease::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.Lease.created_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lease::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Lease::mutable_created_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.Lease.created_at)
  return _msg;
}
inline void Lease::set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.Lease.created_at)
}

// map<string, string> labels = 3;
inline int Lease::_internal_labels_size() const {
  return labels_.size();
}
inline int Lease::labels_size() const {
  return _internal_labels_size();
}
inline void Lease::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lease::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Lease::labels() const {
  // @@protoc_insertion_point(field_map:containerd.services.leases.v1.Lease.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lease::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Lease::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.leases.v1.Lease.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateRequest

// string id = 1;
inline void CreateRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.CreateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.CreateRequest.id)
}
inline std::string* CreateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.CreateRequest.id)
  return _s;
}
inline const std::string& CreateRequest::_internal_id() const {
  return id_.Get();
}
inline void CreateRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.CreateRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.CreateRequest.id)
}

// map<string, string> labels = 3;
inline int CreateRequest::_internal_labels_size() const {
  return labels_.size();
}
inline int CreateRequest::labels_size() const {
  return _internal_labels_size();
}
inline void CreateRequest::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::labels() const {
  // @@protoc_insertion_point(field_map:containerd.services.leases.v1.CreateRequest.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.leases.v1.CreateRequest.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// CreateResponse

// .containerd.services.leases.v1.Lease lease = 1;
inline bool CreateResponse::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool CreateResponse::has_lease() const {
  return _internal_has_lease();
}
inline void CreateResponse::clear_lease() {
  if (GetArenaForAllocation() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::containerd::services::leases::v1::Lease& CreateResponse::_internal_lease() const {
  const ::containerd::services::leases::v1::Lease* p = lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::leases::v1::Lease&>(
      ::containerd::services::leases::v1::_Lease_default_instance_);
}
inline const ::containerd::services::leases::v1::Lease& CreateResponse::lease() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.CreateResponse.lease)
  return _internal_lease();
}
inline void CreateResponse::unsafe_arena_set_allocated_lease(
    ::containerd::services::leases::v1::Lease* lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.leases.v1.CreateResponse.lease)
}
inline ::containerd::services::leases::v1::Lease* CreateResponse::release_lease() {
  
  ::containerd::services::leases::v1::Lease* temp = lease_;
  lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::leases::v1::Lease* CreateResponse::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.CreateResponse.lease)
  
  ::containerd::services::leases::v1::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::containerd::services::leases::v1::Lease* CreateResponse::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::leases::v1::Lease>(GetArenaForAllocation());
    lease_ = p;
  }
  return lease_;
}
inline ::containerd::services::leases::v1::Lease* CreateResponse::mutable_lease() {
  ::containerd::services::leases::v1::Lease* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.CreateResponse.lease)
  return _msg;
}
inline void CreateResponse::set_allocated_lease(::containerd::services::leases::v1::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::leases::v1::Lease>::GetOwningArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.CreateResponse.lease)
}

// -------------------------------------------------------------------

// DeleteRequest

// string id = 1;
inline void DeleteRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.DeleteRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.DeleteRequest.id)
}
inline std::string* DeleteRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.DeleteRequest.id)
  return _s;
}
inline const std::string& DeleteRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.DeleteRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.DeleteRequest.id)
}

// bool sync = 2;
inline void DeleteRequest::clear_sync() {
  sync_ = false;
}
inline bool DeleteRequest::_internal_sync() const {
  return sync_;
}
inline bool DeleteRequest::sync() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.DeleteRequest.sync)
  return _internal_sync();
}
inline void DeleteRequest::_internal_set_sync(bool value) {
  
  sync_ = value;
}
inline void DeleteRequest::set_sync(bool value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.DeleteRequest.sync)
}

// -------------------------------------------------------------------

// ListRequest

// repeated string filters = 1;
inline int ListRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int ListRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* ListRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.leases.v1.ListRequest.filters)
  return _s;
}
inline const std::string& ListRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& ListRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.ListRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.ListRequest.filters)
  return filters_.Mutable(index);
}
inline void ListRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.leases.v1.ListRequest.filters)
}
inline std::string* ListRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void ListRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.leases.v1.ListRequest.filters)
}
inline void ListRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.leases.v1.ListRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.leases.v1.ListRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.leases.v1.ListRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// ListResponse

// repeated .containerd.services.leases.v1.Lease leases = 1;
inline int ListResponse::_internal_leases_size() const {
  return leases_.size();
}
inline int ListResponse::leases_size() const {
  return _internal_leases_size();
}
inline void ListResponse::clear_leases() {
  leases_.Clear();
}
inline ::containerd::services::leases::v1::Lease* ListResponse::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.ListResponse.leases)
  return leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Lease >*
ListResponse::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.leases.v1.ListResponse.leases)
  return &leases_;
}
inline const ::containerd::services::leases::v1::Lease& ListResponse::_internal_leases(int index) const {
  return leases_.Get(index);
}
inline const ::containerd::services::leases::v1::Lease& ListResponse::leases(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.ListResponse.leases)
  return _internal_leases(index);
}
inline ::containerd::services::leases::v1::Lease* ListResponse::_internal_add_leases() {
  return leases_.Add();
}
inline ::containerd::services::leases::v1::Lease* ListResponse::add_leases() {
  ::containerd::services::leases::v1::Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:containerd.services.leases.v1.ListResponse.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Lease >&
ListResponse::leases() const {
  // @@protoc_insertion_point(field_list:containerd.services.leases.v1.ListResponse.leases)
  return leases_;
}

// -------------------------------------------------------------------

// Resource

// string id = 1;
inline void Resource::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Resource::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.Resource.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.Resource.id)
}
inline std::string* Resource::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.Resource.id)
  return _s;
}
inline const std::string& Resource::_internal_id() const {
  return id_.Get();
}
inline void Resource::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Resource::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.Resource.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Resource::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.Resource.id)
}

// string type = 2;
inline void Resource::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Resource::type() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.Resource.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.Resource.type)
}
inline std::string* Resource::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.Resource.type)
  return _s;
}
inline const std::string& Resource::_internal_type() const {
  return type_.Get();
}
inline void Resource::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Resource::release_type() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.Resource.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Resource::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.Resource.type)
}

// -------------------------------------------------------------------

// AddResourceRequest

// string id = 1;
inline void AddResourceRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& AddResourceRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.AddResourceRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddResourceRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.AddResourceRequest.id)
}
inline std::string* AddResourceRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.AddResourceRequest.id)
  return _s;
}
inline const std::string& AddResourceRequest::_internal_id() const {
  return id_.Get();
}
inline void AddResourceRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddResourceRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddResourceRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.AddResourceRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddResourceRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.AddResourceRequest.id)
}

// .containerd.services.leases.v1.Resource resource = 2 [(.gogoproto.nullable) = false];
inline bool AddResourceRequest::_internal_has_resource() const {
  return this != internal_default_instance() && resource_ != nullptr;
}
inline bool AddResourceRequest::has_resource() const {
  return _internal_has_resource();
}
inline void AddResourceRequest::clear_resource() {
  if (GetArenaForAllocation() == nullptr && resource_ != nullptr) {
    delete resource_;
  }
  resource_ = nullptr;
}
inline const ::containerd::services::leases::v1::Resource& AddResourceRequest::_internal_resource() const {
  const ::containerd::services::leases::v1::Resource* p = resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::leases::v1::Resource&>(
      ::containerd::services::leases::v1::_Resource_default_instance_);
}
inline const ::containerd::services::leases::v1::Resource& AddResourceRequest::resource() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.AddResourceRequest.resource)
  return _internal_resource();
}
inline void AddResourceRequest::unsafe_arena_set_allocated_resource(
    ::containerd::services::leases::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_);
  }
  resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.leases.v1.AddResourceRequest.resource)
}
inline ::containerd::services::leases::v1::Resource* AddResourceRequest::release_resource() {
  
  ::containerd::services::leases::v1::Resource* temp = resource_;
  resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::leases::v1::Resource* AddResourceRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.AddResourceRequest.resource)
  
  ::containerd::services::leases::v1::Resource* temp = resource_;
  resource_ = nullptr;
  return temp;
}
inline ::containerd::services::leases::v1::Resource* AddResourceRequest::_internal_mutable_resource() {
  
  if (resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::leases::v1::Resource>(GetArenaForAllocation());
    resource_ = p;
  }
  return resource_;
}
inline ::containerd::services::leases::v1::Resource* AddResourceRequest::mutable_resource() {
  ::containerd::services::leases::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.AddResourceRequest.resource)
  return _msg;
}
inline void AddResourceRequest::set_allocated_resource(::containerd::services::leases::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::leases::v1::Resource>::GetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.AddResourceRequest.resource)
}

// -------------------------------------------------------------------

// DeleteResourceRequest

// string id = 1;
inline void DeleteResourceRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteResourceRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.DeleteResourceRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteResourceRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.DeleteResourceRequest.id)
}
inline std::string* DeleteResourceRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.DeleteResourceRequest.id)
  return _s;
}
inline const std::string& DeleteResourceRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteResourceRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteResourceRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteResourceRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.DeleteResourceRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteResourceRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.DeleteResourceRequest.id)
}

// .containerd.services.leases.v1.Resource resource = 2 [(.gogoproto.nullable) = false];
inline bool DeleteResourceRequest::_internal_has_resource() const {
  return this != internal_default_instance() && resource_ != nullptr;
}
inline bool DeleteResourceRequest::has_resource() const {
  return _internal_has_resource();
}
inline void DeleteResourceRequest::clear_resource() {
  if (GetArenaForAllocation() == nullptr && resource_ != nullptr) {
    delete resource_;
  }
  resource_ = nullptr;
}
inline const ::containerd::services::leases::v1::Resource& DeleteResourceRequest::_internal_resource() const {
  const ::containerd::services::leases::v1::Resource* p = resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::leases::v1::Resource&>(
      ::containerd::services::leases::v1::_Resource_default_instance_);
}
inline const ::containerd::services::leases::v1::Resource& DeleteResourceRequest::resource() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.DeleteResourceRequest.resource)
  return _internal_resource();
}
inline void DeleteResourceRequest::unsafe_arena_set_allocated_resource(
    ::containerd::services::leases::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_);
  }
  resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.leases.v1.DeleteResourceRequest.resource)
}
inline ::containerd::services::leases::v1::Resource* DeleteResourceRequest::release_resource() {
  
  ::containerd::services::leases::v1::Resource* temp = resource_;
  resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::leases::v1::Resource* DeleteResourceRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.DeleteResourceRequest.resource)
  
  ::containerd::services::leases::v1::Resource* temp = resource_;
  resource_ = nullptr;
  return temp;
}
inline ::containerd::services::leases::v1::Resource* DeleteResourceRequest::_internal_mutable_resource() {
  
  if (resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::leases::v1::Resource>(GetArenaForAllocation());
    resource_ = p;
  }
  return resource_;
}
inline ::containerd::services::leases::v1::Resource* DeleteResourceRequest::mutable_resource() {
  ::containerd::services::leases::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.DeleteResourceRequest.resource)
  return _msg;
}
inline void DeleteResourceRequest::set_allocated_resource(::containerd::services::leases::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::leases::v1::Resource>::GetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.DeleteResourceRequest.resource)
}

// -------------------------------------------------------------------

// ListResourcesRequest

// string id = 1;
inline void ListResourcesRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ListResourcesRequest::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.ListResourcesRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResourcesRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.leases.v1.ListResourcesRequest.id)
}
inline std::string* ListResourcesRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.ListResourcesRequest.id)
  return _s;
}
inline const std::string& ListResourcesRequest::_internal_id() const {
  return id_.Get();
}
inline void ListResourcesRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListResourcesRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListResourcesRequest::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.leases.v1.ListResourcesRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListResourcesRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.leases.v1.ListResourcesRequest.id)
}

// -------------------------------------------------------------------

// ListResourcesResponse

// repeated .containerd.services.leases.v1.Resource resources = 1 [(.gogoproto.nullable) = false];
inline int ListResourcesResponse::_internal_resources_size() const {
  return resources_.size();
}
inline int ListResourcesResponse::resources_size() const {
  return _internal_resources_size();
}
inline void ListResourcesResponse::clear_resources() {
  resources_.Clear();
}
inline ::containerd::services::leases::v1::Resource* ListResourcesResponse::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.leases.v1.ListResourcesResponse.resources)
  return resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Resource >*
ListResourcesResponse::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.leases.v1.ListResourcesResponse.resources)
  return &resources_;
}
inline const ::containerd::services::leases::v1::Resource& ListResourcesResponse::_internal_resources(int index) const {
  return resources_.Get(index);
}
inline const ::containerd::services::leases::v1::Resource& ListResourcesResponse::resources(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.leases.v1.ListResourcesResponse.resources)
  return _internal_resources(index);
}
inline ::containerd::services::leases::v1::Resource* ListResourcesResponse::_internal_add_resources() {
  return resources_.Add();
}
inline ::containerd::services::leases::v1::Resource* ListResourcesResponse::add_resources() {
  ::containerd::services::leases::v1::Resource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:containerd.services.leases.v1.ListResourcesResponse.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::leases::v1::Resource >&
ListResourcesResponse::resources() const {
  // @@protoc_insertion_point(field_list:containerd.services.leases.v1.ListResourcesResponse.resources)
  return resources_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace leases
}  // namespace services
}  // namespace containerd

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_leases_2eproto
