// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tasks.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tasks_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tasks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/any.pb.h>
#include "gogo.pb.h"
#include "mount.pb.h"
#include "metrics.pb.h"
#include "descriptor.pb.h"
#include "task.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tasks_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tasks_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tasks_2eproto;
namespace containerd {
namespace services {
namespace tasks {
namespace v1 {
class CheckpointTaskRequest;
struct CheckpointTaskRequestDefaultTypeInternal;
extern CheckpointTaskRequestDefaultTypeInternal _CheckpointTaskRequest_default_instance_;
class CheckpointTaskResponse;
struct CheckpointTaskResponseDefaultTypeInternal;
extern CheckpointTaskResponseDefaultTypeInternal _CheckpointTaskResponse_default_instance_;
class CloseIORequest;
struct CloseIORequestDefaultTypeInternal;
extern CloseIORequestDefaultTypeInternal _CloseIORequest_default_instance_;
class CreateTaskRequest;
struct CreateTaskRequestDefaultTypeInternal;
extern CreateTaskRequestDefaultTypeInternal _CreateTaskRequest_default_instance_;
class CreateTaskResponse;
struct CreateTaskResponseDefaultTypeInternal;
extern CreateTaskResponseDefaultTypeInternal _CreateTaskResponse_default_instance_;
class DeleteProcessRequest;
struct DeleteProcessRequestDefaultTypeInternal;
extern DeleteProcessRequestDefaultTypeInternal _DeleteProcessRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class DeleteTaskRequest;
struct DeleteTaskRequestDefaultTypeInternal;
extern DeleteTaskRequestDefaultTypeInternal _DeleteTaskRequest_default_instance_;
class ExecProcessRequest;
struct ExecProcessRequestDefaultTypeInternal;
extern ExecProcessRequestDefaultTypeInternal _ExecProcessRequest_default_instance_;
class ExecProcessResponse;
struct ExecProcessResponseDefaultTypeInternal;
extern ExecProcessResponseDefaultTypeInternal _ExecProcessResponse_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class KillRequest;
struct KillRequestDefaultTypeInternal;
extern KillRequestDefaultTypeInternal _KillRequest_default_instance_;
class ListPidsRequest;
struct ListPidsRequestDefaultTypeInternal;
extern ListPidsRequestDefaultTypeInternal _ListPidsRequest_default_instance_;
class ListPidsResponse;
struct ListPidsResponseDefaultTypeInternal;
extern ListPidsResponseDefaultTypeInternal _ListPidsResponse_default_instance_;
class ListTasksRequest;
struct ListTasksRequestDefaultTypeInternal;
extern ListTasksRequestDefaultTypeInternal _ListTasksRequest_default_instance_;
class ListTasksResponse;
struct ListTasksResponseDefaultTypeInternal;
extern ListTasksResponseDefaultTypeInternal _ListTasksResponse_default_instance_;
class MetricsRequest;
struct MetricsRequestDefaultTypeInternal;
extern MetricsRequestDefaultTypeInternal _MetricsRequest_default_instance_;
class MetricsResponse;
struct MetricsResponseDefaultTypeInternal;
extern MetricsResponseDefaultTypeInternal _MetricsResponse_default_instance_;
class PauseTaskRequest;
struct PauseTaskRequestDefaultTypeInternal;
extern PauseTaskRequestDefaultTypeInternal _PauseTaskRequest_default_instance_;
class ResizePtyRequest;
struct ResizePtyRequestDefaultTypeInternal;
extern ResizePtyRequestDefaultTypeInternal _ResizePtyRequest_default_instance_;
class ResumeTaskRequest;
struct ResumeTaskRequestDefaultTypeInternal;
extern ResumeTaskRequestDefaultTypeInternal _ResumeTaskRequest_default_instance_;
class StartRequest;
struct StartRequestDefaultTypeInternal;
extern StartRequestDefaultTypeInternal _StartRequest_default_instance_;
class StartResponse;
struct StartResponseDefaultTypeInternal;
extern StartResponseDefaultTypeInternal _StartResponse_default_instance_;
class UpdateTaskRequest;
struct UpdateTaskRequestDefaultTypeInternal;
extern UpdateTaskRequestDefaultTypeInternal _UpdateTaskRequest_default_instance_;
class WaitRequest;
struct WaitRequestDefaultTypeInternal;
extern WaitRequestDefaultTypeInternal _WaitRequest_default_instance_;
class WaitResponse;
struct WaitResponseDefaultTypeInternal;
extern WaitResponseDefaultTypeInternal _WaitResponse_default_instance_;
}  // namespace v1
}  // namespace tasks
}  // namespace services
}  // namespace containerd
PROTOBUF_NAMESPACE_OPEN
template<> ::containerd::services::tasks::v1::CheckpointTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::CheckpointTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::CheckpointTaskResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::CheckpointTaskResponse>(Arena*);
template<> ::containerd::services::tasks::v1::CloseIORequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::CloseIORequest>(Arena*);
template<> ::containerd::services::tasks::v1::CreateTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::CreateTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::CreateTaskResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::CreateTaskResponse>(Arena*);
template<> ::containerd::services::tasks::v1::DeleteProcessRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::DeleteProcessRequest>(Arena*);
template<> ::containerd::services::tasks::v1::DeleteResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::DeleteResponse>(Arena*);
template<> ::containerd::services::tasks::v1::DeleteTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::DeleteTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ExecProcessRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ExecProcessRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ExecProcessResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ExecProcessResponse>(Arena*);
template<> ::containerd::services::tasks::v1::GetRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::GetRequest>(Arena*);
template<> ::containerd::services::tasks::v1::GetResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::GetResponse>(Arena*);
template<> ::containerd::services::tasks::v1::KillRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::KillRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ListPidsRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ListPidsRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ListPidsResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ListPidsResponse>(Arena*);
template<> ::containerd::services::tasks::v1::ListTasksRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ListTasksRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ListTasksResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ListTasksResponse>(Arena*);
template<> ::containerd::services::tasks::v1::MetricsRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::MetricsRequest>(Arena*);
template<> ::containerd::services::tasks::v1::MetricsResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::MetricsResponse>(Arena*);
template<> ::containerd::services::tasks::v1::PauseTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::PauseTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ResizePtyRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ResizePtyRequest>(Arena*);
template<> ::containerd::services::tasks::v1::ResumeTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::ResumeTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::StartRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::StartRequest>(Arena*);
template<> ::containerd::services::tasks::v1::StartResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::StartResponse>(Arena*);
template<> ::containerd::services::tasks::v1::UpdateTaskRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::UpdateTaskRequest>(Arena*);
template<> ::containerd::services::tasks::v1::WaitRequest* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::WaitRequest>(Arena*);
template<> ::containerd::services::tasks::v1::WaitResponse* Arena::CreateMaybeMessage<::containerd::services::tasks::v1::WaitResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace containerd {
namespace services {
namespace tasks {
namespace v1 {

// ===================================================================

class CreateTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.CreateTaskRequest) */ {
 public:
  inline CreateTaskRequest() : CreateTaskRequest(nullptr) {}
  ~CreateTaskRequest() override;
  explicit constexpr CreateTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTaskRequest(const CreateTaskRequest& from);
  CreateTaskRequest(CreateTaskRequest&& from) noexcept
    : CreateTaskRequest() {
    *this = ::std::move(from);
  }

  inline CreateTaskRequest& operator=(const CreateTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskRequest& operator=(CreateTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTaskRequest*>(
               &_CreateTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateTaskRequest& a, CreateTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTaskRequest* New() const final {
    return new CreateTaskRequest();
  }

  CreateTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.CreateTaskRequest";
  }
  protected:
  explicit CreateTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootfsFieldNumber = 3,
    kContainerIdFieldNumber = 1,
    kStdinFieldNumber = 4,
    kStdoutFieldNumber = 5,
    kStderrFieldNumber = 6,
    kCheckpointFieldNumber = 8,
    kOptionsFieldNumber = 9,
    kTerminalFieldNumber = 7,
  };
  // repeated .containerd.types.Mount rootfs = 3;
  int rootfs_size() const;
  private:
  int _internal_rootfs_size() const;
  public:
  void clear_rootfs();
  ::containerd::types::Mount* mutable_rootfs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Mount >*
      mutable_rootfs();
  private:
  const ::containerd::types::Mount& _internal_rootfs(int index) const;
  ::containerd::types::Mount* _internal_add_rootfs();
  public:
  const ::containerd::types::Mount& rootfs(int index) const;
  ::containerd::types::Mount* add_rootfs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Mount >&
      rootfs() const;

  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string stdin = 4;
  void clear_stdin();
  const std::string& stdin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdin();
  PROTOBUF_MUST_USE_RESULT std::string* release_stdin();
  void set_allocated_stdin(std::string* stdin);
  private:
  const std::string& _internal_stdin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdin(const std::string& value);
  std::string* _internal_mutable_stdin();
  public:

  // string stdout = 5;
  void clear_stdout();
  const std::string& stdout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout();
  PROTOBUF_MUST_USE_RESULT std::string* release_stdout();
  void set_allocated_stdout(std::string* stdout);
  private:
  const std::string& _internal_stdout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout(const std::string& value);
  std::string* _internal_mutable_stdout();
  public:

  // string stderr = 6;
  void clear_stderr();
  const std::string& stderr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr();
  PROTOBUF_MUST_USE_RESULT std::string* release_stderr();
  void set_allocated_stderr(std::string* stderr);
  private:
  const std::string& _internal_stderr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr(const std::string& value);
  std::string* _internal_mutable_stderr();
  public:

  // .containerd.types.Descriptor checkpoint = 8;
  bool has_checkpoint() const;
  private:
  bool _internal_has_checkpoint() const;
  public:
  void clear_checkpoint();
  const ::containerd::types::Descriptor& checkpoint() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::types::Descriptor* release_checkpoint();
  ::containerd::types::Descriptor* mutable_checkpoint();
  void set_allocated_checkpoint(::containerd::types::Descriptor* checkpoint);
  private:
  const ::containerd::types::Descriptor& _internal_checkpoint() const;
  ::containerd::types::Descriptor* _internal_mutable_checkpoint();
  public:
  void unsafe_arena_set_allocated_checkpoint(
      ::containerd::types::Descriptor* checkpoint);
  ::containerd::types::Descriptor* unsafe_arena_release_checkpoint();

  // .google.protobuf.Any options = 9;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const PROTOBUF_NAMESPACE_ID::Any& options() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_options();
  PROTOBUF_NAMESPACE_ID::Any* mutable_options();
  void set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_options() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      PROTOBUF_NAMESPACE_ID::Any* options);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_options();

  // bool terminal = 7;
  void clear_terminal();
  bool terminal() const;
  void set_terminal(bool value);
  private:
  bool _internal_terminal() const;
  void _internal_set_terminal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.CreateTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Mount > rootfs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_;
  ::containerd::types::Descriptor* checkpoint_;
  PROTOBUF_NAMESPACE_ID::Any* options_;
  bool terminal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.CreateTaskResponse) */ {
 public:
  inline CreateTaskResponse() : CreateTaskResponse(nullptr) {}
  ~CreateTaskResponse() override;
  explicit constexpr CreateTaskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTaskResponse(const CreateTaskResponse& from);
  CreateTaskResponse(CreateTaskResponse&& from) noexcept
    : CreateTaskResponse() {
    *this = ::std::move(from);
  }

  inline CreateTaskResponse& operator=(const CreateTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskResponse& operator=(CreateTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTaskResponse*>(
               &_CreateTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateTaskResponse& a, CreateTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTaskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTaskResponse* New() const final {
    return new CreateTaskResponse();
  }

  CreateTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTaskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTaskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTaskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.CreateTaskResponse";
  }
  protected:
  explicit CreateTaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // uint32 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.CreateTaskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class StartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.StartRequest) */ {
 public:
  inline StartRequest() : StartRequest(nullptr) {}
  ~StartRequest() override;
  explicit constexpr StartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartRequest(const StartRequest& from);
  StartRequest(StartRequest&& from) noexcept
    : StartRequest() {
    *this = ::std::move(from);
  }

  inline StartRequest& operator=(const StartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRequest& operator=(StartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartRequest* internal_default_instance() {
    return reinterpret_cast<const StartRequest*>(
               &_StartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StartRequest& a, StartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartRequest* New() const final {
    return new StartRequest();
  }

  StartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.StartRequest";
  }
  protected:
  explicit StartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.StartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class StartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.StartResponse) */ {
 public:
  inline StartResponse() : StartResponse(nullptr) {}
  ~StartResponse() override;
  explicit constexpr StartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartResponse(const StartResponse& from);
  StartResponse(StartResponse&& from) noexcept
    : StartResponse() {
    *this = ::std::move(from);
  }

  inline StartResponse& operator=(const StartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartResponse& operator=(StartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartResponse* internal_default_instance() {
    return reinterpret_cast<const StartResponse*>(
               &_StartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartResponse& a, StartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartResponse* New() const final {
    return new StartResponse();
  }

  StartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.StartResponse";
  }
  protected:
  explicit StartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // uint32 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.StartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class DeleteTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.DeleteTaskRequest) */ {
 public:
  inline DeleteTaskRequest() : DeleteTaskRequest(nullptr) {}
  ~DeleteTaskRequest() override;
  explicit constexpr DeleteTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTaskRequest(const DeleteTaskRequest& from);
  DeleteTaskRequest(DeleteTaskRequest&& from) noexcept
    : DeleteTaskRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTaskRequest& operator=(const DeleteTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTaskRequest& operator=(DeleteTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTaskRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTaskRequest*>(
               &_DeleteTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteTaskRequest& a, DeleteTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTaskRequest* New() const final {
    return new DeleteTaskRequest();
  }

  DeleteTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.DeleteTaskRequest";
  }
  protected:
  explicit DeleteTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.DeleteTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  ~DeleteResponse() override;
  explicit constexpr DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return new DeleteResponse();
  }

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kExitedAtFieldNumber = 4,
    kPidFieldNumber = 2,
    kExitStatusFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Timestamp exited_at = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_exited_at() const;
  private:
  bool _internal_has_exited_at() const;
  public:
  void clear_exited_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& exited_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_exited_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_exited_at();
  void set_allocated_exited_at(PROTOBUF_NAMESPACE_ID::Timestamp* exited_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_exited_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_exited_at();
  public:
  void unsafe_arena_set_allocated_exited_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* exited_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_exited_at();

  // uint32 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 exit_status = 3;
  void clear_exit_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_status() const;
  void set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_exit_status() const;
  void _internal_set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* exited_at_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class DeleteProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.DeleteProcessRequest) */ {
 public:
  inline DeleteProcessRequest() : DeleteProcessRequest(nullptr) {}
  ~DeleteProcessRequest() override;
  explicit constexpr DeleteProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProcessRequest(const DeleteProcessRequest& from);
  DeleteProcessRequest(DeleteProcessRequest&& from) noexcept
    : DeleteProcessRequest() {
    *this = ::std::move(from);
  }

  inline DeleteProcessRequest& operator=(const DeleteProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProcessRequest& operator=(DeleteProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProcessRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteProcessRequest*>(
               &_DeleteProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteProcessRequest& a, DeleteProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProcessRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProcessRequest* New() const final {
    return new DeleteProcessRequest();
  }

  DeleteProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProcessRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProcessRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProcessRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProcessRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.DeleteProcessRequest";
  }
  protected:
  explicit DeleteProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.DeleteProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit constexpr GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return new GetRequest();
  }

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit constexpr GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return new GetResponse();
  }

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessFieldNumber = 1,
  };
  // .containerd.v1.types.Process process = 1;
  bool has_process() const;
  private:
  bool _internal_has_process() const;
  public:
  void clear_process();
  const ::containerd::v1::types::Process& process() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::v1::types::Process* release_process();
  ::containerd::v1::types::Process* mutable_process();
  void set_allocated_process(::containerd::v1::types::Process* process);
  private:
  const ::containerd::v1::types::Process& _internal_process() const;
  ::containerd::v1::types::Process* _internal_mutable_process();
  public:
  void unsafe_arena_set_allocated_process(
      ::containerd::v1::types::Process* process);
  ::containerd::v1::types::Process* unsafe_arena_release_process();

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::v1::types::Process* process_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ListTasksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ListTasksRequest) */ {
 public:
  inline ListTasksRequest() : ListTasksRequest(nullptr) {}
  ~ListTasksRequest() override;
  explicit constexpr ListTasksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTasksRequest(const ListTasksRequest& from);
  ListTasksRequest(ListTasksRequest&& from) noexcept
    : ListTasksRequest() {
    *this = ::std::move(from);
  }

  inline ListTasksRequest& operator=(const ListTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTasksRequest& operator=(ListTasksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTasksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTasksRequest* internal_default_instance() {
    return reinterpret_cast<const ListTasksRequest*>(
               &_ListTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListTasksRequest& a, ListTasksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTasksRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTasksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListTasksRequest* New() const final {
    return new ListTasksRequest();
  }

  ListTasksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListTasksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTasksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTasksRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTasksRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ListTasksRequest";
  }
  protected:
  explicit ListTasksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // string filter = 1;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_MUST_USE_RESULT std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ListTasksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ListTasksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ListTasksResponse) */ {
 public:
  inline ListTasksResponse() : ListTasksResponse(nullptr) {}
  ~ListTasksResponse() override;
  explicit constexpr ListTasksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTasksResponse(const ListTasksResponse& from);
  ListTasksResponse(ListTasksResponse&& from) noexcept
    : ListTasksResponse() {
    *this = ::std::move(from);
  }

  inline ListTasksResponse& operator=(const ListTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTasksResponse& operator=(ListTasksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTasksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTasksResponse* internal_default_instance() {
    return reinterpret_cast<const ListTasksResponse*>(
               &_ListTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListTasksResponse& a, ListTasksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTasksResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTasksResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListTasksResponse* New() const final {
    return new ListTasksResponse();
  }

  ListTasksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListTasksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTasksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTasksResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTasksResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ListTasksResponse";
  }
  protected:
  explicit ListTasksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
  };
  // repeated .containerd.v1.types.Process tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::containerd::v1::types::Process* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::Process >*
      mutable_tasks();
  private:
  const ::containerd::v1::types::Process& _internal_tasks(int index) const;
  ::containerd::v1::types::Process* _internal_add_tasks();
  public:
  const ::containerd::v1::types::Process& tasks(int index) const;
  ::containerd::v1::types::Process* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::Process >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ListTasksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::Process > tasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class KillRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.KillRequest) */ {
 public:
  inline KillRequest() : KillRequest(nullptr) {}
  ~KillRequest() override;
  explicit constexpr KillRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KillRequest(const KillRequest& from);
  KillRequest(KillRequest&& from) noexcept
    : KillRequest() {
    *this = ::std::move(from);
  }

  inline KillRequest& operator=(const KillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KillRequest& operator=(KillRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KillRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KillRequest* internal_default_instance() {
    return reinterpret_cast<const KillRequest*>(
               &_KillRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KillRequest& a, KillRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KillRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KillRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KillRequest* New() const final {
    return new KillRequest();
  }

  KillRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KillRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KillRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KillRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KillRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.KillRequest";
  }
  protected:
  explicit KillRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
    kSignalFieldNumber = 3,
    kAllFieldNumber = 4,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // uint32 signal = 3;
  void clear_signal();
  ::PROTOBUF_NAMESPACE_ID::uint32 signal() const;
  void set_signal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_signal() const;
  void _internal_set_signal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool all = 4;
  void clear_all();
  bool all() const;
  void set_all(bool value);
  private:
  bool _internal_all() const;
  void _internal_set_all(bool value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.KillRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 signal_;
  bool all_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ExecProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ExecProcessRequest) */ {
 public:
  inline ExecProcessRequest() : ExecProcessRequest(nullptr) {}
  ~ExecProcessRequest() override;
  explicit constexpr ExecProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecProcessRequest(const ExecProcessRequest& from);
  ExecProcessRequest(ExecProcessRequest&& from) noexcept
    : ExecProcessRequest() {
    *this = ::std::move(from);
  }

  inline ExecProcessRequest& operator=(const ExecProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecProcessRequest& operator=(ExecProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecProcessRequest* internal_default_instance() {
    return reinterpret_cast<const ExecProcessRequest*>(
               &_ExecProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExecProcessRequest& a, ExecProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecProcessRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecProcessRequest* New() const final {
    return new ExecProcessRequest();
  }

  ExecProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecProcessRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecProcessRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecProcessRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecProcessRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ExecProcessRequest";
  }
  protected:
  explicit ExecProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kStdinFieldNumber = 2,
    kStdoutFieldNumber = 3,
    kStderrFieldNumber = 4,
    kExecIdFieldNumber = 7,
    kSpecFieldNumber = 6,
    kTerminalFieldNumber = 5,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string stdin = 2;
  void clear_stdin();
  const std::string& stdin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdin();
  PROTOBUF_MUST_USE_RESULT std::string* release_stdin();
  void set_allocated_stdin(std::string* stdin);
  private:
  const std::string& _internal_stdin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdin(const std::string& value);
  std::string* _internal_mutable_stdin();
  public:

  // string stdout = 3;
  void clear_stdout();
  const std::string& stdout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stdout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stdout();
  PROTOBUF_MUST_USE_RESULT std::string* release_stdout();
  void set_allocated_stdout(std::string* stdout);
  private:
  const std::string& _internal_stdout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stdout(const std::string& value);
  std::string* _internal_mutable_stdout();
  public:

  // string stderr = 4;
  void clear_stderr();
  const std::string& stderr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stderr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stderr();
  PROTOBUF_MUST_USE_RESULT std::string* release_stderr();
  void set_allocated_stderr(std::string* stderr);
  private:
  const std::string& _internal_stderr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stderr(const std::string& value);
  std::string* _internal_mutable_stderr();
  public:

  // string exec_id = 7;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // .google.protobuf.Any spec = 6;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const PROTOBUF_NAMESPACE_ID::Any& spec() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_spec();
  PROTOBUF_NAMESPACE_ID::Any* mutable_spec();
  void set_allocated_spec(PROTOBUF_NAMESPACE_ID::Any* spec);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_spec() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      PROTOBUF_NAMESPACE_ID::Any* spec);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_spec();

  // bool terminal = 5;
  void clear_terminal();
  bool terminal() const;
  void set_terminal(bool value);
  private:
  bool _internal_terminal() const;
  void _internal_set_terminal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ExecProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stdout_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stderr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  PROTOBUF_NAMESPACE_ID::Any* spec_;
  bool terminal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ExecProcessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ExecProcessResponse) */ {
 public:
  inline ExecProcessResponse() : ExecProcessResponse(nullptr) {}
  ~ExecProcessResponse() override;
  explicit constexpr ExecProcessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecProcessResponse(const ExecProcessResponse& from);
  ExecProcessResponse(ExecProcessResponse&& from) noexcept
    : ExecProcessResponse() {
    *this = ::std::move(from);
  }

  inline ExecProcessResponse& operator=(const ExecProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecProcessResponse& operator=(ExecProcessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecProcessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecProcessResponse* internal_default_instance() {
    return reinterpret_cast<const ExecProcessResponse*>(
               &_ExecProcessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExecProcessResponse& a, ExecProcessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecProcessResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecProcessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecProcessResponse* New() const final {
    return new ExecProcessResponse();
  }

  ExecProcessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecProcessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecProcessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecProcessResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecProcessResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ExecProcessResponse";
  }
  protected:
  explicit ExecProcessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ExecProcessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ResizePtyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ResizePtyRequest) */ {
 public:
  inline ResizePtyRequest() : ResizePtyRequest(nullptr) {}
  ~ResizePtyRequest() override;
  explicit constexpr ResizePtyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResizePtyRequest(const ResizePtyRequest& from);
  ResizePtyRequest(ResizePtyRequest&& from) noexcept
    : ResizePtyRequest() {
    *this = ::std::move(from);
  }

  inline ResizePtyRequest& operator=(const ResizePtyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResizePtyRequest& operator=(ResizePtyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResizePtyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResizePtyRequest* internal_default_instance() {
    return reinterpret_cast<const ResizePtyRequest*>(
               &_ResizePtyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResizePtyRequest& a, ResizePtyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResizePtyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResizePtyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResizePtyRequest* New() const final {
    return new ResizePtyRequest();
  }

  ResizePtyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResizePtyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResizePtyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResizePtyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResizePtyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ResizePtyRequest";
  }
  protected:
  explicit ResizePtyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // uint32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ResizePtyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class CloseIORequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.CloseIORequest) */ {
 public:
  inline CloseIORequest() : CloseIORequest(nullptr) {}
  ~CloseIORequest() override;
  explicit constexpr CloseIORequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseIORequest(const CloseIORequest& from);
  CloseIORequest(CloseIORequest&& from) noexcept
    : CloseIORequest() {
    *this = ::std::move(from);
  }

  inline CloseIORequest& operator=(const CloseIORequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseIORequest& operator=(CloseIORequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseIORequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseIORequest* internal_default_instance() {
    return reinterpret_cast<const CloseIORequest*>(
               &_CloseIORequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CloseIORequest& a, CloseIORequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseIORequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseIORequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CloseIORequest* New() const final {
    return new CloseIORequest();
  }

  CloseIORequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CloseIORequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseIORequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseIORequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseIORequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.CloseIORequest";
  }
  protected:
  explicit CloseIORequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
    kStdinFieldNumber = 3,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // bool stdin = 3;
  void clear_stdin();
  bool stdin() const;
  void set_stdin(bool value);
  private:
  bool _internal_stdin() const;
  void _internal_set_stdin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.CloseIORequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  bool stdin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class PauseTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.PauseTaskRequest) */ {
 public:
  inline PauseTaskRequest() : PauseTaskRequest(nullptr) {}
  ~PauseTaskRequest() override;
  explicit constexpr PauseTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseTaskRequest(const PauseTaskRequest& from);
  PauseTaskRequest(PauseTaskRequest&& from) noexcept
    : PauseTaskRequest() {
    *this = ::std::move(from);
  }

  inline PauseTaskRequest& operator=(const PauseTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseTaskRequest& operator=(PauseTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseTaskRequest* internal_default_instance() {
    return reinterpret_cast<const PauseTaskRequest*>(
               &_PauseTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PauseTaskRequest& a, PauseTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PauseTaskRequest* New() const final {
    return new PauseTaskRequest();
  }

  PauseTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PauseTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PauseTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.PauseTaskRequest";
  }
  protected:
  explicit PauseTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.PauseTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ResumeTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ResumeTaskRequest) */ {
 public:
  inline ResumeTaskRequest() : ResumeTaskRequest(nullptr) {}
  ~ResumeTaskRequest() override;
  explicit constexpr ResumeTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResumeTaskRequest(const ResumeTaskRequest& from);
  ResumeTaskRequest(ResumeTaskRequest&& from) noexcept
    : ResumeTaskRequest() {
    *this = ::std::move(from);
  }

  inline ResumeTaskRequest& operator=(const ResumeTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResumeTaskRequest& operator=(ResumeTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResumeTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResumeTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ResumeTaskRequest*>(
               &_ResumeTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResumeTaskRequest& a, ResumeTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResumeTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResumeTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResumeTaskRequest* New() const final {
    return new ResumeTaskRequest();
  }

  ResumeTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResumeTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResumeTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResumeTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResumeTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ResumeTaskRequest";
  }
  protected:
  explicit ResumeTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ResumeTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ListPidsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ListPidsRequest) */ {
 public:
  inline ListPidsRequest() : ListPidsRequest(nullptr) {}
  ~ListPidsRequest() override;
  explicit constexpr ListPidsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPidsRequest(const ListPidsRequest& from);
  ListPidsRequest(ListPidsRequest&& from) noexcept
    : ListPidsRequest() {
    *this = ::std::move(from);
  }

  inline ListPidsRequest& operator=(const ListPidsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPidsRequest& operator=(ListPidsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPidsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPidsRequest* internal_default_instance() {
    return reinterpret_cast<const ListPidsRequest*>(
               &_ListPidsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListPidsRequest& a, ListPidsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPidsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPidsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPidsRequest* New() const final {
    return new ListPidsRequest();
  }

  ListPidsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPidsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPidsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPidsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPidsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ListPidsRequest";
  }
  protected:
  explicit ListPidsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ListPidsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class ListPidsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.ListPidsResponse) */ {
 public:
  inline ListPidsResponse() : ListPidsResponse(nullptr) {}
  ~ListPidsResponse() override;
  explicit constexpr ListPidsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPidsResponse(const ListPidsResponse& from);
  ListPidsResponse(ListPidsResponse&& from) noexcept
    : ListPidsResponse() {
    *this = ::std::move(from);
  }

  inline ListPidsResponse& operator=(const ListPidsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPidsResponse& operator=(ListPidsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPidsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPidsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPidsResponse*>(
               &_ListPidsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListPidsResponse& a, ListPidsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPidsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPidsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPidsResponse* New() const final {
    return new ListPidsResponse();
  }

  ListPidsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPidsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPidsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPidsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPidsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.ListPidsResponse";
  }
  protected:
  explicit ListPidsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessesFieldNumber = 1,
  };
  // repeated .containerd.v1.types.ProcessInfo processes = 1;
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::containerd::v1::types::ProcessInfo* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::ProcessInfo >*
      mutable_processes();
  private:
  const ::containerd::v1::types::ProcessInfo& _internal_processes(int index) const;
  ::containerd::v1::types::ProcessInfo* _internal_add_processes();
  public:
  const ::containerd::v1::types::ProcessInfo& processes(int index) const;
  ::containerd::v1::types::ProcessInfo* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::ProcessInfo >&
      processes() const;

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.ListPidsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::ProcessInfo > processes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class CheckpointTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.CheckpointTaskRequest) */ {
 public:
  inline CheckpointTaskRequest() : CheckpointTaskRequest(nullptr) {}
  ~CheckpointTaskRequest() override;
  explicit constexpr CheckpointTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckpointTaskRequest(const CheckpointTaskRequest& from);
  CheckpointTaskRequest(CheckpointTaskRequest&& from) noexcept
    : CheckpointTaskRequest() {
    *this = ::std::move(from);
  }

  inline CheckpointTaskRequest& operator=(const CheckpointTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointTaskRequest& operator=(CheckpointTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckpointTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckpointTaskRequest* internal_default_instance() {
    return reinterpret_cast<const CheckpointTaskRequest*>(
               &_CheckpointTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CheckpointTaskRequest& a, CheckpointTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckpointTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointTaskRequest* New() const final {
    return new CheckpointTaskRequest();
  }

  CheckpointTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckpointTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckpointTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.CheckpointTaskRequest";
  }
  protected:
  explicit CheckpointTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kParentCheckpointFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string parent_checkpoint = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_parent_checkpoint();
  const std::string& parent_checkpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_checkpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_checkpoint();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_checkpoint();
  void set_allocated_parent_checkpoint(std::string* parent_checkpoint);
  private:
  const std::string& _internal_parent_checkpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_checkpoint(const std::string& value);
  std::string* _internal_mutable_parent_checkpoint();
  public:

  // .google.protobuf.Any options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const PROTOBUF_NAMESPACE_ID::Any& options() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_options();
  PROTOBUF_NAMESPACE_ID::Any* mutable_options();
  void set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_options() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      PROTOBUF_NAMESPACE_ID::Any* options);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.CheckpointTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_checkpoint_;
  PROTOBUF_NAMESPACE_ID::Any* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class CheckpointTaskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.CheckpointTaskResponse) */ {
 public:
  inline CheckpointTaskResponse() : CheckpointTaskResponse(nullptr) {}
  ~CheckpointTaskResponse() override;
  explicit constexpr CheckpointTaskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckpointTaskResponse(const CheckpointTaskResponse& from);
  CheckpointTaskResponse(CheckpointTaskResponse&& from) noexcept
    : CheckpointTaskResponse() {
    *this = ::std::move(from);
  }

  inline CheckpointTaskResponse& operator=(const CheckpointTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointTaskResponse& operator=(CheckpointTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckpointTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckpointTaskResponse* internal_default_instance() {
    return reinterpret_cast<const CheckpointTaskResponse*>(
               &_CheckpointTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CheckpointTaskResponse& a, CheckpointTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointTaskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckpointTaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointTaskResponse* New() const final {
    return new CheckpointTaskResponse();
  }

  CheckpointTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointTaskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckpointTaskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CheckpointTaskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.CheckpointTaskResponse";
  }
  protected:
  explicit CheckpointTaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptorsFieldNumber = 1,
  };
  // repeated .containerd.types.Descriptor descriptors = 1;
  int descriptors_size() const;
  private:
  int _internal_descriptors_size() const;
  public:
  void clear_descriptors();
  ::containerd::types::Descriptor* mutable_descriptors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Descriptor >*
      mutable_descriptors();
  private:
  const ::containerd::types::Descriptor& _internal_descriptors(int index) const;
  ::containerd::types::Descriptor* _internal_add_descriptors();
  public:
  const ::containerd::types::Descriptor& descriptors(int index) const;
  ::containerd::types::Descriptor* add_descriptors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Descriptor >&
      descriptors() const;

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.CheckpointTaskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Descriptor > descriptors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class UpdateTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.UpdateTaskRequest) */ {
 public:
  inline UpdateTaskRequest() : UpdateTaskRequest(nullptr) {}
  ~UpdateTaskRequest() override;
  explicit constexpr UpdateTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTaskRequest(const UpdateTaskRequest& from);
  UpdateTaskRequest(UpdateTaskRequest&& from) noexcept
    : UpdateTaskRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTaskRequest& operator=(const UpdateTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTaskRequest& operator=(UpdateTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTaskRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTaskRequest*>(
               &_UpdateTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateTaskRequest& a, UpdateTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTaskRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateTaskRequest* New() const final {
    return new UpdateTaskRequest();
  }

  UpdateTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.UpdateTaskRequest";
  }
  protected:
  explicit UpdateTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kResourcesFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // .google.protobuf.Any resources = 2;
  bool has_resources() const;
  private:
  bool _internal_has_resources() const;
  public:
  void clear_resources();
  const PROTOBUF_NAMESPACE_ID::Any& resources() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_resources();
  PROTOBUF_NAMESPACE_ID::Any* mutable_resources();
  void set_allocated_resources(PROTOBUF_NAMESPACE_ID::Any* resources);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_resources() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_resources();
  public:
  void unsafe_arena_set_allocated_resources(
      PROTOBUF_NAMESPACE_ID::Any* resources);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_resources();

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.UpdateTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  PROTOBUF_NAMESPACE_ID::Any* resources_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class MetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.MetricsRequest) */ {
 public:
  inline MetricsRequest() : MetricsRequest(nullptr) {}
  ~MetricsRequest() override;
  explicit constexpr MetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsRequest(const MetricsRequest& from);
  MetricsRequest(MetricsRequest&& from) noexcept
    : MetricsRequest() {
    *this = ::std::move(from);
  }

  inline MetricsRequest& operator=(const MetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsRequest& operator=(MetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsRequest* internal_default_instance() {
    return reinterpret_cast<const MetricsRequest*>(
               &_MetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MetricsRequest& a, MetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetricsRequest* New() const final {
    return new MetricsRequest();
  }

  MetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.MetricsRequest";
  }
  protected:
  explicit MetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.MetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class MetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.MetricsResponse) */ {
 public:
  inline MetricsResponse() : MetricsResponse(nullptr) {}
  ~MetricsResponse() override;
  explicit constexpr MetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsResponse(const MetricsResponse& from);
  MetricsResponse(MetricsResponse&& from) noexcept
    : MetricsResponse() {
    *this = ::std::move(from);
  }

  inline MetricsResponse& operator=(const MetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsResponse& operator=(MetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsResponse* internal_default_instance() {
    return reinterpret_cast<const MetricsResponse*>(
               &_MetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MetricsResponse& a, MetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetricsResponse* New() const final {
    return new MetricsResponse();
  }

  MetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.MetricsResponse";
  }
  protected:
  explicit MetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
  };
  // repeated .containerd.types.Metric metrics = 1;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::containerd::types::Metric* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Metric >*
      mutable_metrics();
  private:
  const ::containerd::types::Metric& _internal_metrics(int index) const;
  ::containerd::types::Metric* _internal_add_metrics();
  public:
  const ::containerd::types::Metric& metrics(int index) const;
  ::containerd::types::Metric* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Metric >&
      metrics() const;

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.MetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Metric > metrics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class WaitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.WaitRequest) */ {
 public:
  inline WaitRequest() : WaitRequest(nullptr) {}
  ~WaitRequest() override;
  explicit constexpr WaitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitRequest(const WaitRequest& from);
  WaitRequest(WaitRequest&& from) noexcept
    : WaitRequest() {
    *this = ::std::move(from);
  }

  inline WaitRequest& operator=(const WaitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitRequest& operator=(WaitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitRequest* internal_default_instance() {
    return reinterpret_cast<const WaitRequest*>(
               &_WaitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WaitRequest& a, WaitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaitRequest* New() const final {
    return new WaitRequest();
  }

  WaitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WaitRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.WaitRequest";
  }
  protected:
  explicit WaitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerIdFieldNumber = 1,
    kExecIdFieldNumber = 2,
  };
  // string container_id = 1;
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // string exec_id = 2;
  void clear_exec_id();
  const std::string& exec_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_id();
  void set_allocated_exec_id(std::string* exec_id);
  private:
  const std::string& _internal_exec_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_id(const std::string& value);
  std::string* _internal_mutable_exec_id();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.WaitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// -------------------------------------------------------------------

class WaitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.tasks.v1.WaitResponse) */ {
 public:
  inline WaitResponse() : WaitResponse(nullptr) {}
  ~WaitResponse() override;
  explicit constexpr WaitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitResponse(const WaitResponse& from);
  WaitResponse(WaitResponse&& from) noexcept
    : WaitResponse() {
    *this = ::std::move(from);
  }

  inline WaitResponse& operator=(const WaitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitResponse& operator=(WaitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitResponse* internal_default_instance() {
    return reinterpret_cast<const WaitResponse*>(
               &_WaitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(WaitResponse& a, WaitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaitResponse* New() const final {
    return new WaitResponse();
  }

  WaitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WaitResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.tasks.v1.WaitResponse";
  }
  protected:
  explicit WaitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExitedAtFieldNumber = 2,
    kExitStatusFieldNumber = 1,
  };
  // .google.protobuf.Timestamp exited_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_exited_at() const;
  private:
  bool _internal_has_exited_at() const;
  public:
  void clear_exited_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& exited_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_exited_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_exited_at();
  void set_allocated_exited_at(PROTOBUF_NAMESPACE_ID::Timestamp* exited_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_exited_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_exited_at();
  public:
  void unsafe_arena_set_allocated_exited_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* exited_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_exited_at();

  // uint32 exit_status = 1;
  void clear_exit_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_status() const;
  void set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_exit_status() const;
  void _internal_set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.tasks.v1.WaitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* exited_at_;
  ::PROTOBUF_NAMESPACE_ID::uint32 exit_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tasks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateTaskRequest

// string container_id = 1;
inline void CreateTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskRequest.container_id)
}
inline std::string* CreateTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.container_id)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void CreateTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.container_id)
}

// repeated .containerd.types.Mount rootfs = 3;
inline int CreateTaskRequest::_internal_rootfs_size() const {
  return rootfs_.size();
}
inline int CreateTaskRequest::rootfs_size() const {
  return _internal_rootfs_size();
}
inline ::containerd::types::Mount* CreateTaskRequest::mutable_rootfs(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.rootfs)
  return rootfs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Mount >*
CreateTaskRequest::mutable_rootfs() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.CreateTaskRequest.rootfs)
  return &rootfs_;
}
inline const ::containerd::types::Mount& CreateTaskRequest::_internal_rootfs(int index) const {
  return rootfs_.Get(index);
}
inline const ::containerd::types::Mount& CreateTaskRequest::rootfs(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.rootfs)
  return _internal_rootfs(index);
}
inline ::containerd::types::Mount* CreateTaskRequest::_internal_add_rootfs() {
  return rootfs_.Add();
}
inline ::containerd::types::Mount* CreateTaskRequest::add_rootfs() {
  ::containerd::types::Mount* _add = _internal_add_rootfs();
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.CreateTaskRequest.rootfs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Mount >&
CreateTaskRequest::rootfs() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.CreateTaskRequest.rootfs)
  return rootfs_;
}

// string stdin = 4;
inline void CreateTaskRequest::clear_stdin() {
  stdin_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::stdin() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.stdin)
  return _internal_stdin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTaskRequest::set_stdin(ArgT0&& arg0, ArgT... args) {
 
 stdin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskRequest.stdin)
}
inline std::string* CreateTaskRequest::mutable_stdin() {
  std::string* _s = _internal_mutable_stdin();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.stdin)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_stdin() const {
  return stdin_.Get();
}
inline void CreateTaskRequest::_internal_set_stdin(const std::string& value) {
  
  stdin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::_internal_mutable_stdin() {
  
  return stdin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::release_stdin() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.stdin)
  return stdin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTaskRequest::set_allocated_stdin(std::string* stdin) {
  if (stdin != nullptr) {
    
  } else {
    
  }
  stdin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stdin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.stdin)
}

// string stdout = 5;
inline void CreateTaskRequest::clear_stdout() {
  stdout_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::stdout() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.stdout)
  return _internal_stdout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTaskRequest::set_stdout(ArgT0&& arg0, ArgT... args) {
 
 stdout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskRequest.stdout)
}
inline std::string* CreateTaskRequest::mutable_stdout() {
  std::string* _s = _internal_mutable_stdout();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.stdout)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_stdout() const {
  return stdout_.Get();
}
inline void CreateTaskRequest::_internal_set_stdout(const std::string& value) {
  
  stdout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::_internal_mutable_stdout() {
  
  return stdout_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::release_stdout() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.stdout)
  return stdout_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTaskRequest::set_allocated_stdout(std::string* stdout) {
  if (stdout != nullptr) {
    
  } else {
    
  }
  stdout_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stdout,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.stdout)
}

// string stderr = 6;
inline void CreateTaskRequest::clear_stderr() {
  stderr_.ClearToEmpty();
}
inline const std::string& CreateTaskRequest::stderr() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.stderr)
  return _internal_stderr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTaskRequest::set_stderr(ArgT0&& arg0, ArgT... args) {
 
 stderr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskRequest.stderr)
}
inline std::string* CreateTaskRequest::mutable_stderr() {
  std::string* _s = _internal_mutable_stderr();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.stderr)
  return _s;
}
inline const std::string& CreateTaskRequest::_internal_stderr() const {
  return stderr_.Get();
}
inline void CreateTaskRequest::_internal_set_stderr(const std::string& value) {
  
  stderr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::_internal_mutable_stderr() {
  
  return stderr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTaskRequest::release_stderr() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.stderr)
  return stderr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTaskRequest::set_allocated_stderr(std::string* stderr) {
  if (stderr != nullptr) {
    
  } else {
    
  }
  stderr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stderr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.stderr)
}

// bool terminal = 7;
inline void CreateTaskRequest::clear_terminal() {
  terminal_ = false;
}
inline bool CreateTaskRequest::_internal_terminal() const {
  return terminal_;
}
inline bool CreateTaskRequest::terminal() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.terminal)
  return _internal_terminal();
}
inline void CreateTaskRequest::_internal_set_terminal(bool value) {
  
  terminal_ = value;
}
inline void CreateTaskRequest::set_terminal(bool value) {
  _internal_set_terminal(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskRequest.terminal)
}

// .containerd.types.Descriptor checkpoint = 8;
inline bool CreateTaskRequest::_internal_has_checkpoint() const {
  return this != internal_default_instance() && checkpoint_ != nullptr;
}
inline bool CreateTaskRequest::has_checkpoint() const {
  return _internal_has_checkpoint();
}
inline const ::containerd::types::Descriptor& CreateTaskRequest::_internal_checkpoint() const {
  const ::containerd::types::Descriptor* p = checkpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::types::Descriptor&>(
      ::containerd::types::_Descriptor_default_instance_);
}
inline const ::containerd::types::Descriptor& CreateTaskRequest::checkpoint() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.checkpoint)
  return _internal_checkpoint();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_checkpoint(
    ::containerd::types::Descriptor* checkpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checkpoint_);
  }
  checkpoint_ = checkpoint;
  if (checkpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.checkpoint)
}
inline ::containerd::types::Descriptor* CreateTaskRequest::release_checkpoint() {
  
  ::containerd::types::Descriptor* temp = checkpoint_;
  checkpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::types::Descriptor* CreateTaskRequest::unsafe_arena_release_checkpoint() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.checkpoint)
  
  ::containerd::types::Descriptor* temp = checkpoint_;
  checkpoint_ = nullptr;
  return temp;
}
inline ::containerd::types::Descriptor* CreateTaskRequest::_internal_mutable_checkpoint() {
  
  if (checkpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::types::Descriptor>(GetArenaForAllocation());
    checkpoint_ = p;
  }
  return checkpoint_;
}
inline ::containerd::types::Descriptor* CreateTaskRequest::mutable_checkpoint() {
  ::containerd::types::Descriptor* _msg = _internal_mutable_checkpoint();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.checkpoint)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_checkpoint(::containerd::types::Descriptor* checkpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(checkpoint_);
  }
  if (checkpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checkpoint));
    if (message_arena != submessage_arena) {
      checkpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checkpoint, submessage_arena);
    }
    
  } else {
    
  }
  checkpoint_ = checkpoint;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.checkpoint)
}

// .google.protobuf.Any options = 9;
inline bool CreateTaskRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool CreateTaskRequest::has_options() const {
  return _internal_has_options();
}
inline const PROTOBUF_NAMESPACE_ID::Any& CreateTaskRequest::_internal_options() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& CreateTaskRequest::options() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskRequest.options)
  return _internal_options();
}
inline void CreateTaskRequest::unsafe_arena_set_allocated_options(
    PROTOBUF_NAMESPACE_ID::Any* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.options)
}
inline PROTOBUF_NAMESPACE_ID::Any* CreateTaskRequest::release_options() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* CreateTaskRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskRequest.options)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* CreateTaskRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline PROTOBUF_NAMESPACE_ID::Any* CreateTaskRequest::mutable_options() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskRequest.options)
  return _msg;
}
inline void CreateTaskRequest::set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskRequest.options)
}

// -------------------------------------------------------------------

// CreateTaskResponse

// string container_id = 1;
inline void CreateTaskResponse::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& CreateTaskResponse::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskResponse.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTaskResponse::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskResponse.container_id)
}
inline std::string* CreateTaskResponse::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CreateTaskResponse.container_id)
  return _s;
}
inline const std::string& CreateTaskResponse::_internal_container_id() const {
  return container_id_.Get();
}
inline void CreateTaskResponse::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTaskResponse::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTaskResponse::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CreateTaskResponse.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTaskResponse::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CreateTaskResponse.container_id)
}

// uint32 pid = 2;
inline void CreateTaskResponse::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateTaskResponse::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateTaskResponse::pid() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CreateTaskResponse.pid)
  return _internal_pid();
}
inline void CreateTaskResponse::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void CreateTaskResponse::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CreateTaskResponse.pid)
}

// -------------------------------------------------------------------

// StartRequest

// string container_id = 1;
inline void StartRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& StartRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.StartRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.StartRequest.container_id)
}
inline std::string* StartRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.StartRequest.container_id)
  return _s;
}
inline const std::string& StartRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void StartRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.StartRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.StartRequest.container_id)
}

// string exec_id = 2;
inline void StartRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& StartRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.StartRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.StartRequest.exec_id)
}
inline std::string* StartRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.StartRequest.exec_id)
  return _s;
}
inline const std::string& StartRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void StartRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StartRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StartRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.StartRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StartRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.StartRequest.exec_id)
}

// -------------------------------------------------------------------

// StartResponse

// uint32 pid = 1;
inline void StartResponse::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StartResponse::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StartResponse::pid() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.StartResponse.pid)
  return _internal_pid();
}
inline void StartResponse::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void StartResponse::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.StartResponse.pid)
}

// -------------------------------------------------------------------

// DeleteTaskRequest

// string container_id = 1;
inline void DeleteTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& DeleteTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteTaskRequest.container_id)
}
inline std::string* DeleteTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.DeleteTaskRequest.container_id)
  return _s;
}
inline const std::string& DeleteTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void DeleteTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.DeleteTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.DeleteTaskRequest.container_id)
}

// -------------------------------------------------------------------

// DeleteResponse

// string id = 1;
inline void DeleteResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteResponse::id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteResponse.id)
}
inline std::string* DeleteResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.DeleteResponse.id)
  return _s;
}
inline const std::string& DeleteResponse::_internal_id() const {
  return id_.Get();
}
inline void DeleteResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteResponse::release_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.DeleteResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.DeleteResponse.id)
}

// uint32 pid = 2;
inline void DeleteResponse::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteResponse::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteResponse::pid() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteResponse.pid)
  return _internal_pid();
}
inline void DeleteResponse::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void DeleteResponse::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteResponse.pid)
}

// uint32 exit_status = 3;
inline void DeleteResponse::clear_exit_status() {
  exit_status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteResponse::_internal_exit_status() const {
  return exit_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteResponse::exit_status() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteResponse.exit_status)
  return _internal_exit_status();
}
inline void DeleteResponse::_internal_set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  exit_status_ = value;
}
inline void DeleteResponse::set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_exit_status(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteResponse.exit_status)
}

// .google.protobuf.Timestamp exited_at = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool DeleteResponse::_internal_has_exited_at() const {
  return this != internal_default_instance() && exited_at_ != nullptr;
}
inline bool DeleteResponse::has_exited_at() const {
  return _internal_has_exited_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& DeleteResponse::_internal_exited_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = exited_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& DeleteResponse::exited_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteResponse.exited_at)
  return _internal_exited_at();
}
inline void DeleteResponse::unsafe_arena_set_allocated_exited_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* exited_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at_);
  }
  exited_at_ = exited_at;
  if (exited_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.DeleteResponse.exited_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* DeleteResponse::release_exited_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = exited_at_;
  exited_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* DeleteResponse::unsafe_arena_release_exited_at() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.DeleteResponse.exited_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = exited_at_;
  exited_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* DeleteResponse::_internal_mutable_exited_at() {
  
  if (exited_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    exited_at_ = p;
  }
  return exited_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* DeleteResponse::mutable_exited_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_exited_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.DeleteResponse.exited_at)
  return _msg;
}
inline void DeleteResponse::set_allocated_exited_at(PROTOBUF_NAMESPACE_ID::Timestamp* exited_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at_);
  }
  if (exited_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at));
    if (message_arena != submessage_arena) {
      exited_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exited_at, submessage_arena);
    }
    
  } else {
    
  }
  exited_at_ = exited_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.DeleteResponse.exited_at)
}

// -------------------------------------------------------------------

// DeleteProcessRequest

// string container_id = 1;
inline void DeleteProcessRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& DeleteProcessRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteProcessRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProcessRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteProcessRequest.container_id)
}
inline std::string* DeleteProcessRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.DeleteProcessRequest.container_id)
  return _s;
}
inline const std::string& DeleteProcessRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void DeleteProcessRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProcessRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProcessRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.DeleteProcessRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProcessRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.DeleteProcessRequest.container_id)
}

// string exec_id = 2;
inline void DeleteProcessRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& DeleteProcessRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.DeleteProcessRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProcessRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.DeleteProcessRequest.exec_id)
}
inline std::string* DeleteProcessRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.DeleteProcessRequest.exec_id)
  return _s;
}
inline const std::string& DeleteProcessRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void DeleteProcessRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProcessRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProcessRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.DeleteProcessRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProcessRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.DeleteProcessRequest.exec_id)
}

// -------------------------------------------------------------------

// GetRequest

// string container_id = 1;
inline void GetRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& GetRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.GetRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.GetRequest.container_id)
}
inline std::string* GetRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.GetRequest.container_id)
  return _s;
}
inline const std::string& GetRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void GetRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.GetRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.GetRequest.container_id)
}

// string exec_id = 2;
inline void GetRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& GetRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.GetRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.GetRequest.exec_id)
}
inline std::string* GetRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.GetRequest.exec_id)
  return _s;
}
inline const std::string& GetRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void GetRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.GetRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.GetRequest.exec_id)
}

// -------------------------------------------------------------------

// GetResponse

// .containerd.v1.types.Process process = 1;
inline bool GetResponse::_internal_has_process() const {
  return this != internal_default_instance() && process_ != nullptr;
}
inline bool GetResponse::has_process() const {
  return _internal_has_process();
}
inline const ::containerd::v1::types::Process& GetResponse::_internal_process() const {
  const ::containerd::v1::types::Process* p = process_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::v1::types::Process&>(
      ::containerd::v1::types::_Process_default_instance_);
}
inline const ::containerd::v1::types::Process& GetResponse::process() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.GetResponse.process)
  return _internal_process();
}
inline void GetResponse::unsafe_arena_set_allocated_process(
    ::containerd::v1::types::Process* process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_);
  }
  process_ = process;
  if (process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.GetResponse.process)
}
inline ::containerd::v1::types::Process* GetResponse::release_process() {
  
  ::containerd::v1::types::Process* temp = process_;
  process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::v1::types::Process* GetResponse::unsafe_arena_release_process() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.GetResponse.process)
  
  ::containerd::v1::types::Process* temp = process_;
  process_ = nullptr;
  return temp;
}
inline ::containerd::v1::types::Process* GetResponse::_internal_mutable_process() {
  
  if (process_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::v1::types::Process>(GetArenaForAllocation());
    process_ = p;
  }
  return process_;
}
inline ::containerd::v1::types::Process* GetResponse::mutable_process() {
  ::containerd::v1::types::Process* _msg = _internal_mutable_process();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.GetResponse.process)
  return _msg;
}
inline void GetResponse::set_allocated_process(::containerd::v1::types::Process* process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_);
  }
  if (process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process));
    if (message_arena != submessage_arena) {
      process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.GetResponse.process)
}

// -------------------------------------------------------------------

// ListTasksRequest

// string filter = 1;
inline void ListTasksRequest::clear_filter() {
  filter_.ClearToEmpty();
}
inline const std::string& ListTasksRequest::filter() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ListTasksRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTasksRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ListTasksRequest.filter)
}
inline std::string* ListTasksRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ListTasksRequest.filter)
  return _s;
}
inline const std::string& ListTasksRequest::_internal_filter() const {
  return filter_.Get();
}
inline void ListTasksRequest::_internal_set_filter(const std::string& value) {
  
  filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListTasksRequest::_internal_mutable_filter() {
  
  return filter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListTasksRequest::release_filter() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ListTasksRequest.filter)
  return filter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListTasksRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ListTasksRequest.filter)
}

// -------------------------------------------------------------------

// ListTasksResponse

// repeated .containerd.v1.types.Process tasks = 1;
inline int ListTasksResponse::_internal_tasks_size() const {
  return tasks_.size();
}
inline int ListTasksResponse::tasks_size() const {
  return _internal_tasks_size();
}
inline ::containerd::v1::types::Process* ListTasksResponse::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ListTasksResponse.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::Process >*
ListTasksResponse::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.ListTasksResponse.tasks)
  return &tasks_;
}
inline const ::containerd::v1::types::Process& ListTasksResponse::_internal_tasks(int index) const {
  return tasks_.Get(index);
}
inline const ::containerd::v1::types::Process& ListTasksResponse::tasks(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ListTasksResponse.tasks)
  return _internal_tasks(index);
}
inline ::containerd::v1::types::Process* ListTasksResponse::_internal_add_tasks() {
  return tasks_.Add();
}
inline ::containerd::v1::types::Process* ListTasksResponse::add_tasks() {
  ::containerd::v1::types::Process* _add = _internal_add_tasks();
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.ListTasksResponse.tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::Process >&
ListTasksResponse::tasks() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.ListTasksResponse.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// KillRequest

// string container_id = 1;
inline void KillRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& KillRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.KillRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KillRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.KillRequest.container_id)
}
inline std::string* KillRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.KillRequest.container_id)
  return _s;
}
inline const std::string& KillRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void KillRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KillRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KillRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.KillRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KillRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.KillRequest.container_id)
}

// string exec_id = 2;
inline void KillRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& KillRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.KillRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KillRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.KillRequest.exec_id)
}
inline std::string* KillRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.KillRequest.exec_id)
  return _s;
}
inline const std::string& KillRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void KillRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KillRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KillRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.KillRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KillRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.KillRequest.exec_id)
}

// uint32 signal = 3;
inline void KillRequest::clear_signal() {
  signal_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KillRequest::_internal_signal() const {
  return signal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 KillRequest::signal() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.KillRequest.signal)
  return _internal_signal();
}
inline void KillRequest::_internal_set_signal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  signal_ = value;
}
inline void KillRequest::set_signal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.KillRequest.signal)
}

// bool all = 4;
inline void KillRequest::clear_all() {
  all_ = false;
}
inline bool KillRequest::_internal_all() const {
  return all_;
}
inline bool KillRequest::all() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.KillRequest.all)
  return _internal_all();
}
inline void KillRequest::_internal_set_all(bool value) {
  
  all_ = value;
}
inline void KillRequest::set_all(bool value) {
  _internal_set_all(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.KillRequest.all)
}

// -------------------------------------------------------------------

// ExecProcessRequest

// string container_id = 1;
inline void ExecProcessRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& ExecProcessRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecProcessRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.container_id)
}
inline std::string* ExecProcessRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.container_id)
  return _s;
}
inline const std::string& ExecProcessRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void ExecProcessRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecProcessRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.container_id)
}

// string stdin = 2;
inline void ExecProcessRequest::clear_stdin() {
  stdin_.ClearToEmpty();
}
inline const std::string& ExecProcessRequest::stdin() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.stdin)
  return _internal_stdin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecProcessRequest::set_stdin(ArgT0&& arg0, ArgT... args) {
 
 stdin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.stdin)
}
inline std::string* ExecProcessRequest::mutable_stdin() {
  std::string* _s = _internal_mutable_stdin();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.stdin)
  return _s;
}
inline const std::string& ExecProcessRequest::_internal_stdin() const {
  return stdin_.Get();
}
inline void ExecProcessRequest::_internal_set_stdin(const std::string& value) {
  
  stdin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::_internal_mutable_stdin() {
  
  return stdin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::release_stdin() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.stdin)
  return stdin_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecProcessRequest::set_allocated_stdin(std::string* stdin) {
  if (stdin != nullptr) {
    
  } else {
    
  }
  stdin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stdin,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.stdin)
}

// string stdout = 3;
inline void ExecProcessRequest::clear_stdout() {
  stdout_.ClearToEmpty();
}
inline const std::string& ExecProcessRequest::stdout() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.stdout)
  return _internal_stdout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecProcessRequest::set_stdout(ArgT0&& arg0, ArgT... args) {
 
 stdout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.stdout)
}
inline std::string* ExecProcessRequest::mutable_stdout() {
  std::string* _s = _internal_mutable_stdout();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.stdout)
  return _s;
}
inline const std::string& ExecProcessRequest::_internal_stdout() const {
  return stdout_.Get();
}
inline void ExecProcessRequest::_internal_set_stdout(const std::string& value) {
  
  stdout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::_internal_mutable_stdout() {
  
  return stdout_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::release_stdout() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.stdout)
  return stdout_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecProcessRequest::set_allocated_stdout(std::string* stdout) {
  if (stdout != nullptr) {
    
  } else {
    
  }
  stdout_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stdout,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.stdout)
}

// string stderr = 4;
inline void ExecProcessRequest::clear_stderr() {
  stderr_.ClearToEmpty();
}
inline const std::string& ExecProcessRequest::stderr() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.stderr)
  return _internal_stderr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecProcessRequest::set_stderr(ArgT0&& arg0, ArgT... args) {
 
 stderr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.stderr)
}
inline std::string* ExecProcessRequest::mutable_stderr() {
  std::string* _s = _internal_mutable_stderr();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.stderr)
  return _s;
}
inline const std::string& ExecProcessRequest::_internal_stderr() const {
  return stderr_.Get();
}
inline void ExecProcessRequest::_internal_set_stderr(const std::string& value) {
  
  stderr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::_internal_mutable_stderr() {
  
  return stderr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::release_stderr() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.stderr)
  return stderr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecProcessRequest::set_allocated_stderr(std::string* stderr) {
  if (stderr != nullptr) {
    
  } else {
    
  }
  stderr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stderr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.stderr)
}

// bool terminal = 5;
inline void ExecProcessRequest::clear_terminal() {
  terminal_ = false;
}
inline bool ExecProcessRequest::_internal_terminal() const {
  return terminal_;
}
inline bool ExecProcessRequest::terminal() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.terminal)
  return _internal_terminal();
}
inline void ExecProcessRequest::_internal_set_terminal(bool value) {
  
  terminal_ = value;
}
inline void ExecProcessRequest::set_terminal(bool value) {
  _internal_set_terminal(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.terminal)
}

// .google.protobuf.Any spec = 6;
inline bool ExecProcessRequest::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool ExecProcessRequest::has_spec() const {
  return _internal_has_spec();
}
inline const PROTOBUF_NAMESPACE_ID::Any& ExecProcessRequest::_internal_spec() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& ExecProcessRequest::spec() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.spec)
  return _internal_spec();
}
inline void ExecProcessRequest::unsafe_arena_set_allocated_spec(
    PROTOBUF_NAMESPACE_ID::Any* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.spec)
}
inline PROTOBUF_NAMESPACE_ID::Any* ExecProcessRequest::release_spec() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* ExecProcessRequest::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.spec)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* ExecProcessRequest::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline PROTOBUF_NAMESPACE_ID::Any* ExecProcessRequest::mutable_spec() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.spec)
  return _msg;
}
inline void ExecProcessRequest::set_allocated_spec(PROTOBUF_NAMESPACE_ID::Any* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec));
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.spec)
}

// string exec_id = 7;
inline void ExecProcessRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& ExecProcessRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ExecProcessRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecProcessRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ExecProcessRequest.exec_id)
}
inline std::string* ExecProcessRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ExecProcessRequest.exec_id)
  return _s;
}
inline const std::string& ExecProcessRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void ExecProcessRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecProcessRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ExecProcessRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecProcessRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ExecProcessRequest.exec_id)
}

// -------------------------------------------------------------------

// ExecProcessResponse

// -------------------------------------------------------------------

// ResizePtyRequest

// string container_id = 1;
inline void ResizePtyRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& ResizePtyRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ResizePtyRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResizePtyRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ResizePtyRequest.container_id)
}
inline std::string* ResizePtyRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ResizePtyRequest.container_id)
  return _s;
}
inline const std::string& ResizePtyRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void ResizePtyRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResizePtyRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResizePtyRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ResizePtyRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResizePtyRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ResizePtyRequest.container_id)
}

// string exec_id = 2;
inline void ResizePtyRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& ResizePtyRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ResizePtyRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResizePtyRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ResizePtyRequest.exec_id)
}
inline std::string* ResizePtyRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ResizePtyRequest.exec_id)
  return _s;
}
inline const std::string& ResizePtyRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void ResizePtyRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResizePtyRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResizePtyRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ResizePtyRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResizePtyRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ResizePtyRequest.exec_id)
}

// uint32 width = 3;
inline void ResizePtyRequest::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResizePtyRequest::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResizePtyRequest::width() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ResizePtyRequest.width)
  return _internal_width();
}
inline void ResizePtyRequest::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void ResizePtyRequest::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ResizePtyRequest.width)
}

// uint32 height = 4;
inline void ResizePtyRequest::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResizePtyRequest::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResizePtyRequest::height() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ResizePtyRequest.height)
  return _internal_height();
}
inline void ResizePtyRequest::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void ResizePtyRequest::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ResizePtyRequest.height)
}

// -------------------------------------------------------------------

// CloseIORequest

// string container_id = 1;
inline void CloseIORequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& CloseIORequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CloseIORequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseIORequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CloseIORequest.container_id)
}
inline std::string* CloseIORequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CloseIORequest.container_id)
  return _s;
}
inline const std::string& CloseIORequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void CloseIORequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CloseIORequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CloseIORequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CloseIORequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CloseIORequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CloseIORequest.container_id)
}

// string exec_id = 2;
inline void CloseIORequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& CloseIORequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CloseIORequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseIORequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CloseIORequest.exec_id)
}
inline std::string* CloseIORequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CloseIORequest.exec_id)
  return _s;
}
inline const std::string& CloseIORequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void CloseIORequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CloseIORequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CloseIORequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CloseIORequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CloseIORequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CloseIORequest.exec_id)
}

// bool stdin = 3;
inline void CloseIORequest::clear_stdin() {
  stdin_ = false;
}
inline bool CloseIORequest::_internal_stdin() const {
  return stdin_;
}
inline bool CloseIORequest::stdin() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CloseIORequest.stdin)
  return _internal_stdin();
}
inline void CloseIORequest::_internal_set_stdin(bool value) {
  
  stdin_ = value;
}
inline void CloseIORequest::set_stdin(bool value) {
  _internal_set_stdin(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CloseIORequest.stdin)
}

// -------------------------------------------------------------------

// PauseTaskRequest

// string container_id = 1;
inline void PauseTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& PauseTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.PauseTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.PauseTaskRequest.container_id)
}
inline std::string* PauseTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.PauseTaskRequest.container_id)
  return _s;
}
inline const std::string& PauseTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void PauseTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PauseTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PauseTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.PauseTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PauseTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.PauseTaskRequest.container_id)
}

// -------------------------------------------------------------------

// ResumeTaskRequest

// string container_id = 1;
inline void ResumeTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& ResumeTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ResumeTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResumeTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ResumeTaskRequest.container_id)
}
inline std::string* ResumeTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ResumeTaskRequest.container_id)
  return _s;
}
inline const std::string& ResumeTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void ResumeTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResumeTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResumeTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ResumeTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResumeTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ResumeTaskRequest.container_id)
}

// -------------------------------------------------------------------

// ListPidsRequest

// string container_id = 1;
inline void ListPidsRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& ListPidsRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ListPidsRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPidsRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.ListPidsRequest.container_id)
}
inline std::string* ListPidsRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ListPidsRequest.container_id)
  return _s;
}
inline const std::string& ListPidsRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void ListPidsRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPidsRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPidsRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.ListPidsRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPidsRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.ListPidsRequest.container_id)
}

// -------------------------------------------------------------------

// ListPidsResponse

// repeated .containerd.v1.types.ProcessInfo processes = 1;
inline int ListPidsResponse::_internal_processes_size() const {
  return processes_.size();
}
inline int ListPidsResponse::processes_size() const {
  return _internal_processes_size();
}
inline ::containerd::v1::types::ProcessInfo* ListPidsResponse::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.ListPidsResponse.processes)
  return processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::ProcessInfo >*
ListPidsResponse::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.ListPidsResponse.processes)
  return &processes_;
}
inline const ::containerd::v1::types::ProcessInfo& ListPidsResponse::_internal_processes(int index) const {
  return processes_.Get(index);
}
inline const ::containerd::v1::types::ProcessInfo& ListPidsResponse::processes(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.ListPidsResponse.processes)
  return _internal_processes(index);
}
inline ::containerd::v1::types::ProcessInfo* ListPidsResponse::_internal_add_processes() {
  return processes_.Add();
}
inline ::containerd::v1::types::ProcessInfo* ListPidsResponse::add_processes() {
  ::containerd::v1::types::ProcessInfo* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.ListPidsResponse.processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::v1::types::ProcessInfo >&
ListPidsResponse::processes() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.ListPidsResponse.processes)
  return processes_;
}

// -------------------------------------------------------------------

// CheckpointTaskRequest

// string container_id = 1;
inline void CheckpointTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& CheckpointTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CheckpointTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckpointTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CheckpointTaskRequest.container_id)
}
inline std::string* CheckpointTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CheckpointTaskRequest.container_id)
  return _s;
}
inline const std::string& CheckpointTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void CheckpointTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckpointTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckpointTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CheckpointTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckpointTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CheckpointTaskRequest.container_id)
}

// string parent_checkpoint = 2 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void CheckpointTaskRequest::clear_parent_checkpoint() {
  parent_checkpoint_.ClearToEmpty();
}
inline const std::string& CheckpointTaskRequest::parent_checkpoint() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CheckpointTaskRequest.parent_checkpoint)
  return _internal_parent_checkpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckpointTaskRequest::set_parent_checkpoint(ArgT0&& arg0, ArgT... args) {
 
 parent_checkpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.CheckpointTaskRequest.parent_checkpoint)
}
inline std::string* CheckpointTaskRequest::mutable_parent_checkpoint() {
  std::string* _s = _internal_mutable_parent_checkpoint();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CheckpointTaskRequest.parent_checkpoint)
  return _s;
}
inline const std::string& CheckpointTaskRequest::_internal_parent_checkpoint() const {
  return parent_checkpoint_.Get();
}
inline void CheckpointTaskRequest::_internal_set_parent_checkpoint(const std::string& value) {
  
  parent_checkpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CheckpointTaskRequest::_internal_mutable_parent_checkpoint() {
  
  return parent_checkpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CheckpointTaskRequest::release_parent_checkpoint() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CheckpointTaskRequest.parent_checkpoint)
  return parent_checkpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CheckpointTaskRequest::set_allocated_parent_checkpoint(std::string* parent_checkpoint) {
  if (parent_checkpoint != nullptr) {
    
  } else {
    
  }
  parent_checkpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_checkpoint,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CheckpointTaskRequest.parent_checkpoint)
}

// .google.protobuf.Any options = 3;
inline bool CheckpointTaskRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool CheckpointTaskRequest::has_options() const {
  return _internal_has_options();
}
inline const PROTOBUF_NAMESPACE_ID::Any& CheckpointTaskRequest::_internal_options() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& CheckpointTaskRequest::options() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CheckpointTaskRequest.options)
  return _internal_options();
}
inline void CheckpointTaskRequest::unsafe_arena_set_allocated_options(
    PROTOBUF_NAMESPACE_ID::Any* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.CheckpointTaskRequest.options)
}
inline PROTOBUF_NAMESPACE_ID::Any* CheckpointTaskRequest::release_options() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* CheckpointTaskRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.CheckpointTaskRequest.options)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = options_;
  options_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* CheckpointTaskRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline PROTOBUF_NAMESPACE_ID::Any* CheckpointTaskRequest::mutable_options() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CheckpointTaskRequest.options)
  return _msg;
}
inline void CheckpointTaskRequest::set_allocated_options(PROTOBUF_NAMESPACE_ID::Any* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.CheckpointTaskRequest.options)
}

// -------------------------------------------------------------------

// CheckpointTaskResponse

// repeated .containerd.types.Descriptor descriptors = 1;
inline int CheckpointTaskResponse::_internal_descriptors_size() const {
  return descriptors_.size();
}
inline int CheckpointTaskResponse::descriptors_size() const {
  return _internal_descriptors_size();
}
inline ::containerd::types::Descriptor* CheckpointTaskResponse::mutable_descriptors(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.CheckpointTaskResponse.descriptors)
  return descriptors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Descriptor >*
CheckpointTaskResponse::mutable_descriptors() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.CheckpointTaskResponse.descriptors)
  return &descriptors_;
}
inline const ::containerd::types::Descriptor& CheckpointTaskResponse::_internal_descriptors(int index) const {
  return descriptors_.Get(index);
}
inline const ::containerd::types::Descriptor& CheckpointTaskResponse::descriptors(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.CheckpointTaskResponse.descriptors)
  return _internal_descriptors(index);
}
inline ::containerd::types::Descriptor* CheckpointTaskResponse::_internal_add_descriptors() {
  return descriptors_.Add();
}
inline ::containerd::types::Descriptor* CheckpointTaskResponse::add_descriptors() {
  ::containerd::types::Descriptor* _add = _internal_add_descriptors();
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.CheckpointTaskResponse.descriptors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Descriptor >&
CheckpointTaskResponse::descriptors() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.CheckpointTaskResponse.descriptors)
  return descriptors_;
}

// -------------------------------------------------------------------

// UpdateTaskRequest

// string container_id = 1;
inline void UpdateTaskRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& UpdateTaskRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.UpdateTaskRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTaskRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.UpdateTaskRequest.container_id)
}
inline std::string* UpdateTaskRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.UpdateTaskRequest.container_id)
  return _s;
}
inline const std::string& UpdateTaskRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void UpdateTaskRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateTaskRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateTaskRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.UpdateTaskRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateTaskRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.UpdateTaskRequest.container_id)
}

// .google.protobuf.Any resources = 2;
inline bool UpdateTaskRequest::_internal_has_resources() const {
  return this != internal_default_instance() && resources_ != nullptr;
}
inline bool UpdateTaskRequest::has_resources() const {
  return _internal_has_resources();
}
inline const PROTOBUF_NAMESPACE_ID::Any& UpdateTaskRequest::_internal_resources() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = resources_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& UpdateTaskRequest::resources() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.UpdateTaskRequest.resources)
  return _internal_resources();
}
inline void UpdateTaskRequest::unsafe_arena_set_allocated_resources(
    PROTOBUF_NAMESPACE_ID::Any* resources) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resources_);
  }
  resources_ = resources;
  if (resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.UpdateTaskRequest.resources)
}
inline PROTOBUF_NAMESPACE_ID::Any* UpdateTaskRequest::release_resources() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = resources_;
  resources_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* UpdateTaskRequest::unsafe_arena_release_resources() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.UpdateTaskRequest.resources)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = resources_;
  resources_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* UpdateTaskRequest::_internal_mutable_resources() {
  
  if (resources_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    resources_ = p;
  }
  return resources_;
}
inline PROTOBUF_NAMESPACE_ID::Any* UpdateTaskRequest::mutable_resources() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_resources();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.UpdateTaskRequest.resources)
  return _msg;
}
inline void UpdateTaskRequest::set_allocated_resources(PROTOBUF_NAMESPACE_ID::Any* resources) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resources_);
  }
  if (resources) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resources));
    if (message_arena != submessage_arena) {
      resources = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.UpdateTaskRequest.resources)
}

// -------------------------------------------------------------------

// MetricsRequest

// repeated string filters = 1;
inline int MetricsRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int MetricsRequest::filters_size() const {
  return _internal_filters_size();
}
inline void MetricsRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* MetricsRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.tasks.v1.MetricsRequest.filters)
  return _s;
}
inline const std::string& MetricsRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& MetricsRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.MetricsRequest.filters)
  return _internal_filters(index);
}
inline std::string* MetricsRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.MetricsRequest.filters)
  return filters_.Mutable(index);
}
inline void MetricsRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline std::string* MetricsRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void MetricsRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline void MetricsRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.tasks.v1.MetricsRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MetricsRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.MetricsRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MetricsRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.MetricsRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// MetricsResponse

// repeated .containerd.types.Metric metrics = 1;
inline int MetricsResponse::_internal_metrics_size() const {
  return metrics_.size();
}
inline int MetricsResponse::metrics_size() const {
  return _internal_metrics_size();
}
inline ::containerd::types::Metric* MetricsResponse::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.MetricsResponse.metrics)
  return metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Metric >*
MetricsResponse::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.tasks.v1.MetricsResponse.metrics)
  return &metrics_;
}
inline const ::containerd::types::Metric& MetricsResponse::_internal_metrics(int index) const {
  return metrics_.Get(index);
}
inline const ::containerd::types::Metric& MetricsResponse::metrics(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.MetricsResponse.metrics)
  return _internal_metrics(index);
}
inline ::containerd::types::Metric* MetricsResponse::_internal_add_metrics() {
  return metrics_.Add();
}
inline ::containerd::types::Metric* MetricsResponse::add_metrics() {
  ::containerd::types::Metric* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:containerd.services.tasks.v1.MetricsResponse.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::types::Metric >&
MetricsResponse::metrics() const {
  // @@protoc_insertion_point(field_list:containerd.services.tasks.v1.MetricsResponse.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// WaitRequest

// string container_id = 1;
inline void WaitRequest::clear_container_id() {
  container_id_.ClearToEmpty();
}
inline const std::string& WaitRequest::container_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.WaitRequest.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitRequest::set_container_id(ArgT0&& arg0, ArgT... args) {
 
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.WaitRequest.container_id)
}
inline std::string* WaitRequest::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.WaitRequest.container_id)
  return _s;
}
inline const std::string& WaitRequest::_internal_container_id() const {
  return container_id_.Get();
}
inline void WaitRequest::_internal_set_container_id(const std::string& value) {
  
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WaitRequest::_internal_mutable_container_id() {
  
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WaitRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.WaitRequest.container_id)
  return container_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WaitRequest::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    
  } else {
    
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.WaitRequest.container_id)
}

// string exec_id = 2;
inline void WaitRequest::clear_exec_id() {
  exec_id_.ClearToEmpty();
}
inline const std::string& WaitRequest::exec_id() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.WaitRequest.exec_id)
  return _internal_exec_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitRequest::set_exec_id(ArgT0&& arg0, ArgT... args) {
 
 exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.WaitRequest.exec_id)
}
inline std::string* WaitRequest::mutable_exec_id() {
  std::string* _s = _internal_mutable_exec_id();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.WaitRequest.exec_id)
  return _s;
}
inline const std::string& WaitRequest::_internal_exec_id() const {
  return exec_id_.Get();
}
inline void WaitRequest::_internal_set_exec_id(const std::string& value) {
  
  exec_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WaitRequest::_internal_mutable_exec_id() {
  
  return exec_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WaitRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.WaitRequest.exec_id)
  return exec_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WaitRequest::set_allocated_exec_id(std::string* exec_id) {
  if (exec_id != nullptr) {
    
  } else {
    
  }
  exec_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.WaitRequest.exec_id)
}

// -------------------------------------------------------------------

// WaitResponse

// uint32 exit_status = 1;
inline void WaitResponse::clear_exit_status() {
  exit_status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaitResponse::_internal_exit_status() const {
  return exit_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaitResponse::exit_status() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.WaitResponse.exit_status)
  return _internal_exit_status();
}
inline void WaitResponse::_internal_set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  exit_status_ = value;
}
inline void WaitResponse::set_exit_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_exit_status(value);
  // @@protoc_insertion_point(field_set:containerd.services.tasks.v1.WaitResponse.exit_status)
}

// .google.protobuf.Timestamp exited_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool WaitResponse::_internal_has_exited_at() const {
  return this != internal_default_instance() && exited_at_ != nullptr;
}
inline bool WaitResponse::has_exited_at() const {
  return _internal_has_exited_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WaitResponse::_internal_exited_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = exited_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WaitResponse::exited_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.tasks.v1.WaitResponse.exited_at)
  return _internal_exited_at();
}
inline void WaitResponse::unsafe_arena_set_allocated_exited_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* exited_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at_);
  }
  exited_at_ = exited_at;
  if (exited_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.tasks.v1.WaitResponse.exited_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WaitResponse::release_exited_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = exited_at_;
  exited_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WaitResponse::unsafe_arena_release_exited_at() {
  // @@protoc_insertion_point(field_release:containerd.services.tasks.v1.WaitResponse.exited_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = exited_at_;
  exited_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WaitResponse::_internal_mutable_exited_at() {
  
  if (exited_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    exited_at_ = p;
  }
  return exited_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WaitResponse::mutable_exited_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_exited_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.tasks.v1.WaitResponse.exited_at)
  return _msg;
}
inline void WaitResponse::set_allocated_exited_at(PROTOBUF_NAMESPACE_ID::Timestamp* exited_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at_);
  }
  if (exited_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exited_at));
    if (message_arena != submessage_arena) {
      exited_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exited_at, submessage_arena);
    }
    
  } else {
    
  }
  exited_at_ = exited_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.tasks.v1.WaitResponse.exited_at)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace tasks
}  // namespace services
}  // namespace containerd

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tasks_2eproto
