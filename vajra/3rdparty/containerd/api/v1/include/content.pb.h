// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: content.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_content_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_content_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogo.pb.h"
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_content_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_content_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_content_2eproto;
namespace containerd {
namespace services {
namespace content {
namespace v1 {
class AbortRequest;
struct AbortRequestDefaultTypeInternal;
extern AbortRequestDefaultTypeInternal _AbortRequest_default_instance_;
class DeleteContentRequest;
struct DeleteContentRequestDefaultTypeInternal;
extern DeleteContentRequestDefaultTypeInternal _DeleteContentRequest_default_instance_;
class Info;
struct InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class InfoRequest;
struct InfoRequestDefaultTypeInternal;
extern InfoRequestDefaultTypeInternal _InfoRequest_default_instance_;
class InfoResponse;
struct InfoResponseDefaultTypeInternal;
extern InfoResponseDefaultTypeInternal _InfoResponse_default_instance_;
class Info_LabelsEntry_DoNotUse;
struct Info_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Info_LabelsEntry_DoNotUseDefaultTypeInternal _Info_LabelsEntry_DoNotUse_default_instance_;
class ListContentRequest;
struct ListContentRequestDefaultTypeInternal;
extern ListContentRequestDefaultTypeInternal _ListContentRequest_default_instance_;
class ListContentResponse;
struct ListContentResponseDefaultTypeInternal;
extern ListContentResponseDefaultTypeInternal _ListContentResponse_default_instance_;
class ListStatusesRequest;
struct ListStatusesRequestDefaultTypeInternal;
extern ListStatusesRequestDefaultTypeInternal _ListStatusesRequest_default_instance_;
class ListStatusesResponse;
struct ListStatusesResponseDefaultTypeInternal;
extern ListStatusesResponseDefaultTypeInternal _ListStatusesResponse_default_instance_;
class ReadContentRequest;
struct ReadContentRequestDefaultTypeInternal;
extern ReadContentRequestDefaultTypeInternal _ReadContentRequest_default_instance_;
class ReadContentResponse;
struct ReadContentResponseDefaultTypeInternal;
extern ReadContentResponseDefaultTypeInternal _ReadContentResponse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusRequest;
struct StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class UpdateRequest;
struct UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
struct UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
class WriteContentRequest;
struct WriteContentRequestDefaultTypeInternal;
extern WriteContentRequestDefaultTypeInternal _WriteContentRequest_default_instance_;
class WriteContentRequest_LabelsEntry_DoNotUse;
struct WriteContentRequest_LabelsEntry_DoNotUseDefaultTypeInternal;
extern WriteContentRequest_LabelsEntry_DoNotUseDefaultTypeInternal _WriteContentRequest_LabelsEntry_DoNotUse_default_instance_;
class WriteContentResponse;
struct WriteContentResponseDefaultTypeInternal;
extern WriteContentResponseDefaultTypeInternal _WriteContentResponse_default_instance_;
}  // namespace v1
}  // namespace content
}  // namespace services
}  // namespace containerd
PROTOBUF_NAMESPACE_OPEN
template<> ::containerd::services::content::v1::AbortRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::AbortRequest>(Arena*);
template<> ::containerd::services::content::v1::DeleteContentRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::DeleteContentRequest>(Arena*);
template<> ::containerd::services::content::v1::Info* Arena::CreateMaybeMessage<::containerd::services::content::v1::Info>(Arena*);
template<> ::containerd::services::content::v1::InfoRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::InfoRequest>(Arena*);
template<> ::containerd::services::content::v1::InfoResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::InfoResponse>(Arena*);
template<> ::containerd::services::content::v1::Info_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::content::v1::Info_LabelsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::content::v1::ListContentRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::ListContentRequest>(Arena*);
template<> ::containerd::services::content::v1::ListContentResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::ListContentResponse>(Arena*);
template<> ::containerd::services::content::v1::ListStatusesRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::ListStatusesRequest>(Arena*);
template<> ::containerd::services::content::v1::ListStatusesResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::ListStatusesResponse>(Arena*);
template<> ::containerd::services::content::v1::ReadContentRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::ReadContentRequest>(Arena*);
template<> ::containerd::services::content::v1::ReadContentResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::ReadContentResponse>(Arena*);
template<> ::containerd::services::content::v1::Status* Arena::CreateMaybeMessage<::containerd::services::content::v1::Status>(Arena*);
template<> ::containerd::services::content::v1::StatusRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::StatusRequest>(Arena*);
template<> ::containerd::services::content::v1::StatusResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::StatusResponse>(Arena*);
template<> ::containerd::services::content::v1::UpdateRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::UpdateRequest>(Arena*);
template<> ::containerd::services::content::v1::UpdateResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::UpdateResponse>(Arena*);
template<> ::containerd::services::content::v1::WriteContentRequest* Arena::CreateMaybeMessage<::containerd::services::content::v1::WriteContentRequest>(Arena*);
template<> ::containerd::services::content::v1::WriteContentRequest_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::containerd::services::content::v1::WriteContentRequest_LabelsEntry_DoNotUse>(Arena*);
template<> ::containerd::services::content::v1::WriteContentResponse* Arena::CreateMaybeMessage<::containerd::services::content::v1::WriteContentResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace containerd {
namespace services {
namespace content {
namespace v1 {

enum WriteAction : int {
  STAT = 0,
  WRITE = 1,
  COMMIT = 2,
  WriteAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WriteAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WriteAction_IsValid(int value);
constexpr WriteAction WriteAction_MIN = STAT;
constexpr WriteAction WriteAction_MAX = COMMIT;
constexpr int WriteAction_ARRAYSIZE = WriteAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WriteAction_descriptor();
template<typename T>
inline const std::string& WriteAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WriteAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WriteAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WriteAction_descriptor(), enum_t_value);
}
inline bool WriteAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WriteAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WriteAction>(
    WriteAction_descriptor(), name, value);
}
// ===================================================================

class Info_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Info_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Info_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Info_LabelsEntry_DoNotUse();
  explicit constexpr Info_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Info_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Info_LabelsEntry_DoNotUse& other);
  static const Info_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Info_LabelsEntry_DoNotUse*>(&_Info_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.content.v1.Info.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.content.v1.Info.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  explicit constexpr Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Info* New() const final {
    return new Info();
  }

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 5,
    kDigestFieldNumber = 1,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
    kSizeFieldNumber = 2,
  };
  // map<string, string> labels = 5;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // .google.protobuf.Timestamp created_at = 3 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // int64 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Info_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class InfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.InfoRequest) */ {
 public:
  inline InfoRequest() : InfoRequest(nullptr) {}
  ~InfoRequest() override;
  explicit constexpr InfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoRequest(const InfoRequest& from);
  InfoRequest(InfoRequest&& from) noexcept
    : InfoRequest() {
    *this = ::std::move(from);
  }

  inline InfoRequest& operator=(const InfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoRequest& operator=(InfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoRequest* internal_default_instance() {
    return reinterpret_cast<const InfoRequest*>(
               &_InfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InfoRequest& a, InfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoRequest* New() const final {
    return new InfoRequest();
  }

  InfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.InfoRequest";
  }
  protected:
  explicit InfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 1,
  };
  // string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.InfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class InfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.InfoResponse) */ {
 public:
  inline InfoResponse() : InfoResponse(nullptr) {}
  ~InfoResponse() override;
  explicit constexpr InfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoResponse(const InfoResponse& from);
  InfoResponse(InfoResponse&& from) noexcept
    : InfoResponse() {
    *this = ::std::move(from);
  }

  inline InfoResponse& operator=(const InfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoResponse& operator=(InfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoResponse* internal_default_instance() {
    return reinterpret_cast<const InfoResponse*>(
               &_InfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InfoResponse& a, InfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoResponse* New() const final {
    return new InfoResponse();
  }

  InfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.InfoResponse";
  }
  protected:
  explicit InfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::containerd::services::content::v1::Info& info() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::content::v1::Info* release_info();
  ::containerd::services::content::v1::Info* mutable_info();
  void set_allocated_info(::containerd::services::content::v1::Info* info);
  private:
  const ::containerd::services::content::v1::Info& _internal_info() const;
  ::containerd::services::content::v1::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::containerd::services::content::v1::Info* info);
  ::containerd::services::content::v1::Info* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.InfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::content::v1::Info* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {}
  ~UpdateRequest() override;
  explicit constexpr UpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRequest(const UpdateRequest& from);
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRequest* New() const final {
    return new UpdateRequest();
  }

  UpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::containerd::services::content::v1::Info& info() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::content::v1::Info* release_info();
  ::containerd::services::content::v1::Info* mutable_info();
  void set_allocated_info(::containerd::services::content::v1::Info* info);
  private:
  const ::containerd::services::content::v1::Info& _internal_info() const;
  ::containerd::services::content::v1::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::containerd::services::content::v1::Info* info);
  ::containerd::services::content::v1::Info* unsafe_arena_release_info();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.UpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::content::v1::Info* info_;
  PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.UpdateResponse) */ {
 public:
  inline UpdateResponse() : UpdateResponse(nullptr) {}
  ~UpdateResponse() override;
  explicit constexpr UpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateResponse(const UpdateResponse& from);
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateResponse* New() const final {
    return new UpdateResponse();
  }

  UpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.UpdateResponse";
  }
  protected:
  explicit UpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::containerd::services::content::v1::Info& info() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::content::v1::Info* release_info();
  ::containerd::services::content::v1::Info* mutable_info();
  void set_allocated_info(::containerd::services::content::v1::Info* info);
  private:
  const ::containerd::services::content::v1::Info& _internal_info() const;
  ::containerd::services::content::v1::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::containerd::services::content::v1::Info* info);
  ::containerd::services::content::v1::Info* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.UpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::content::v1::Info* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ListContentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ListContentRequest) */ {
 public:
  inline ListContentRequest() : ListContentRequest(nullptr) {}
  ~ListContentRequest() override;
  explicit constexpr ListContentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListContentRequest(const ListContentRequest& from);
  ListContentRequest(ListContentRequest&& from) noexcept
    : ListContentRequest() {
    *this = ::std::move(from);
  }

  inline ListContentRequest& operator=(const ListContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListContentRequest& operator=(ListContentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListContentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListContentRequest* internal_default_instance() {
    return reinterpret_cast<const ListContentRequest*>(
               &_ListContentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListContentRequest& a, ListContentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListContentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListContentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListContentRequest* New() const final {
    return new ListContentRequest();
  }

  ListContentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListContentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListContentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListContentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListContentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ListContentRequest";
  }
  protected:
  explicit ListContentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ListContentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ListContentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ListContentResponse) */ {
 public:
  inline ListContentResponse() : ListContentResponse(nullptr) {}
  ~ListContentResponse() override;
  explicit constexpr ListContentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListContentResponse(const ListContentResponse& from);
  ListContentResponse(ListContentResponse&& from) noexcept
    : ListContentResponse() {
    *this = ::std::move(from);
  }

  inline ListContentResponse& operator=(const ListContentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListContentResponse& operator=(ListContentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListContentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListContentResponse* internal_default_instance() {
    return reinterpret_cast<const ListContentResponse*>(
               &_ListContentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListContentResponse& a, ListContentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListContentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListContentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListContentResponse* New() const final {
    return new ListContentResponse();
  }

  ListContentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListContentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListContentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListContentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListContentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ListContentResponse";
  }
  protected:
  explicit ListContentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::containerd::services::content::v1::Info* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Info >*
      mutable_info();
  private:
  const ::containerd::services::content::v1::Info& _internal_info(int index) const;
  ::containerd::services::content::v1::Info* _internal_add_info();
  public:
  const ::containerd::services::content::v1::Info& info(int index) const;
  ::containerd::services::content::v1::Info* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Info >&
      info() const;

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ListContentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Info > info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class DeleteContentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.DeleteContentRequest) */ {
 public:
  inline DeleteContentRequest() : DeleteContentRequest(nullptr) {}
  ~DeleteContentRequest() override;
  explicit constexpr DeleteContentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteContentRequest(const DeleteContentRequest& from);
  DeleteContentRequest(DeleteContentRequest&& from) noexcept
    : DeleteContentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteContentRequest& operator=(const DeleteContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteContentRequest& operator=(DeleteContentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteContentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteContentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteContentRequest*>(
               &_DeleteContentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteContentRequest& a, DeleteContentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteContentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteContentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteContentRequest* New() const final {
    return new DeleteContentRequest();
  }

  DeleteContentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteContentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteContentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteContentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteContentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.DeleteContentRequest";
  }
  protected:
  explicit DeleteContentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 1,
  };
  // string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.DeleteContentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ReadContentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ReadContentRequest) */ {
 public:
  inline ReadContentRequest() : ReadContentRequest(nullptr) {}
  ~ReadContentRequest() override;
  explicit constexpr ReadContentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadContentRequest(const ReadContentRequest& from);
  ReadContentRequest(ReadContentRequest&& from) noexcept
    : ReadContentRequest() {
    *this = ::std::move(from);
  }

  inline ReadContentRequest& operator=(const ReadContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadContentRequest& operator=(ReadContentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadContentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadContentRequest* internal_default_instance() {
    return reinterpret_cast<const ReadContentRequest*>(
               &_ReadContentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadContentRequest& a, ReadContentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadContentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadContentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadContentRequest* New() const final {
    return new ReadContentRequest();
  }

  ReadContentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadContentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadContentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadContentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadContentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ReadContentRequest";
  }
  protected:
  explicit ReadContentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // int64 offset = 2;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ReadContentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ReadContentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ReadContentResponse) */ {
 public:
  inline ReadContentResponse() : ReadContentResponse(nullptr) {}
  ~ReadContentResponse() override;
  explicit constexpr ReadContentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadContentResponse(const ReadContentResponse& from);
  ReadContentResponse(ReadContentResponse&& from) noexcept
    : ReadContentResponse() {
    *this = ::std::move(from);
  }

  inline ReadContentResponse& operator=(const ReadContentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadContentResponse& operator=(ReadContentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadContentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadContentResponse* internal_default_instance() {
    return reinterpret_cast<const ReadContentResponse*>(
               &_ReadContentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReadContentResponse& a, ReadContentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadContentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadContentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadContentResponse* New() const final {
    return new ReadContentResponse();
  }

  ReadContentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadContentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadContentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadContentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadContentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ReadContentResponse";
  }
  protected:
  explicit ReadContentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOffsetFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 offset = 1;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ReadContentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit constexpr Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return new Status();
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefFieldNumber = 3,
    kExpectedFieldNumber = 6,
    kStartedAtFieldNumber = 1,
    kUpdatedAtFieldNumber = 2,
    kOffsetFieldNumber = 4,
    kTotalFieldNumber = 5,
  };
  // string ref = 3;
  void clear_ref();
  const std::string& ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref();
  PROTOBUF_MUST_USE_RESULT std::string* release_ref();
  void set_allocated_ref(std::string* ref);
  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(const std::string& value);
  std::string* _internal_mutable_ref();
  public:

  // string expected = 6 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_expected();
  const std::string& expected() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expected(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expected();
  PROTOBUF_MUST_USE_RESULT std::string* release_expected();
  void set_allocated_expected(std::string* expected);
  private:
  const std::string& _internal_expected() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expected(const std::string& value);
  std::string* _internal_mutable_expected();
  public:

  // .google.protobuf.Timestamp started_at = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // .google.protobuf.Timestamp updated_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // int64 offset = 4;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 total = 5;
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_;
  PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class StatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.StatusRequest) */ {
 public:
  inline StatusRequest() : StatusRequest(nullptr) {}
  ~StatusRequest() override;
  explicit constexpr StatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusRequest(const StatusRequest& from);
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const final {
    return new StatusRequest();
  }

  StatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.StatusRequest";
  }
  protected:
  explicit StatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefFieldNumber = 1,
  };
  // string ref = 1;
  void clear_ref();
  const std::string& ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref();
  PROTOBUF_MUST_USE_RESULT std::string* release_ref();
  void set_allocated_ref(std::string* ref);
  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(const std::string& value);
  std::string* _internal_mutable_ref();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.StatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit constexpr StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return new StatusResponse();
  }

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .containerd.services.content.v1.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::containerd::services::content::v1::Status& status() const;
  PROTOBUF_MUST_USE_RESULT ::containerd::services::content::v1::Status* release_status();
  ::containerd::services::content::v1::Status* mutable_status();
  void set_allocated_status(::containerd::services::content::v1::Status* status);
  private:
  const ::containerd::services::content::v1::Status& _internal_status() const;
  ::containerd::services::content::v1::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::containerd::services::content::v1::Status* status);
  ::containerd::services::content::v1::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::containerd::services::content::v1::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ListStatusesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ListStatusesRequest) */ {
 public:
  inline ListStatusesRequest() : ListStatusesRequest(nullptr) {}
  ~ListStatusesRequest() override;
  explicit constexpr ListStatusesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStatusesRequest(const ListStatusesRequest& from);
  ListStatusesRequest(ListStatusesRequest&& from) noexcept
    : ListStatusesRequest() {
    *this = ::std::move(from);
  }

  inline ListStatusesRequest& operator=(const ListStatusesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStatusesRequest& operator=(ListStatusesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStatusesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStatusesRequest* internal_default_instance() {
    return reinterpret_cast<const ListStatusesRequest*>(
               &_ListStatusesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListStatusesRequest& a, ListStatusesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStatusesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStatusesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListStatusesRequest* New() const final {
    return new ListStatusesRequest();
  }

  ListStatusesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListStatusesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStatusesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListStatusesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStatusesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ListStatusesRequest";
  }
  protected:
  explicit ListStatusesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated string filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ListStatusesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class ListStatusesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.ListStatusesResponse) */ {
 public:
  inline ListStatusesResponse() : ListStatusesResponse(nullptr) {}
  ~ListStatusesResponse() override;
  explicit constexpr ListStatusesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStatusesResponse(const ListStatusesResponse& from);
  ListStatusesResponse(ListStatusesResponse&& from) noexcept
    : ListStatusesResponse() {
    *this = ::std::move(from);
  }

  inline ListStatusesResponse& operator=(const ListStatusesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStatusesResponse& operator=(ListStatusesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStatusesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStatusesResponse* internal_default_instance() {
    return reinterpret_cast<const ListStatusesResponse*>(
               &_ListStatusesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListStatusesResponse& a, ListStatusesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStatusesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStatusesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListStatusesResponse* New() const final {
    return new ListStatusesResponse();
  }

  ListStatusesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListStatusesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStatusesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListStatusesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStatusesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.ListStatusesResponse";
  }
  protected:
  explicit ListStatusesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusesFieldNumber = 1,
  };
  // repeated .containerd.services.content.v1.Status statuses = 1 [(.gogoproto.nullable) = false];
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;
  public:
  void clear_statuses();
  ::containerd::services::content::v1::Status* mutable_statuses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Status >*
      mutable_statuses();
  private:
  const ::containerd::services::content::v1::Status& _internal_statuses(int index) const;
  ::containerd::services::content::v1::Status* _internal_add_statuses();
  public:
  const ::containerd::services::content::v1::Status& statuses(int index) const;
  ::containerd::services::content::v1::Status* add_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Status >&
      statuses() const;

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.ListStatusesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Status > statuses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class WriteContentRequest_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteContentRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteContentRequest_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WriteContentRequest_LabelsEntry_DoNotUse();
  explicit constexpr WriteContentRequest_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WriteContentRequest_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WriteContentRequest_LabelsEntry_DoNotUse& other);
  static const WriteContentRequest_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WriteContentRequest_LabelsEntry_DoNotUse*>(&_WriteContentRequest_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.content.v1.WriteContentRequest.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "containerd.services.content.v1.WriteContentRequest.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WriteContentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.WriteContentRequest) */ {
 public:
  inline WriteContentRequest() : WriteContentRequest(nullptr) {}
  ~WriteContentRequest() override;
  explicit constexpr WriteContentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteContentRequest(const WriteContentRequest& from);
  WriteContentRequest(WriteContentRequest&& from) noexcept
    : WriteContentRequest() {
    *this = ::std::move(from);
  }

  inline WriteContentRequest& operator=(const WriteContentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteContentRequest& operator=(WriteContentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteContentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteContentRequest* internal_default_instance() {
    return reinterpret_cast<const WriteContentRequest*>(
               &_WriteContentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WriteContentRequest& a, WriteContentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteContentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteContentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteContentRequest* New() const final {
    return new WriteContentRequest();
  }

  WriteContentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteContentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteContentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteContentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteContentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.WriteContentRequest";
  }
  protected:
  explicit WriteContentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 7,
    kRefFieldNumber = 2,
    kExpectedFieldNumber = 4,
    kDataFieldNumber = 6,
    kTotalFieldNumber = 3,
    kOffsetFieldNumber = 5,
    kActionFieldNumber = 1,
  };
  // map<string, string> labels = 7;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string ref = 2;
  void clear_ref();
  const std::string& ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref();
  PROTOBUF_MUST_USE_RESULT std::string* release_ref();
  void set_allocated_ref(std::string* ref);
  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(const std::string& value);
  std::string* _internal_mutable_ref();
  public:

  // string expected = 4 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_expected();
  const std::string& expected() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expected(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expected();
  PROTOBUF_MUST_USE_RESULT std::string* release_expected();
  void set_allocated_expected(std::string* expected);
  private:
  const std::string& _internal_expected() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expected(const std::string& value);
  std::string* _internal_mutable_expected();
  public:

  // bytes data = 6;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 total = 3;
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 offset = 5;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .containerd.services.content.v1.WriteAction action = 1;
  void clear_action();
  ::containerd::services::content::v1::WriteAction action() const;
  void set_action(::containerd::services::content::v1::WriteAction value);
  private:
  ::containerd::services::content::v1::WriteAction _internal_action() const;
  void _internal_set_action(::containerd::services::content::v1::WriteAction value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.WriteContentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WriteContentRequest_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class WriteContentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.WriteContentResponse) */ {
 public:
  inline WriteContentResponse() : WriteContentResponse(nullptr) {}
  ~WriteContentResponse() override;
  explicit constexpr WriteContentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteContentResponse(const WriteContentResponse& from);
  WriteContentResponse(WriteContentResponse&& from) noexcept
    : WriteContentResponse() {
    *this = ::std::move(from);
  }

  inline WriteContentResponse& operator=(const WriteContentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteContentResponse& operator=(WriteContentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteContentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteContentResponse* internal_default_instance() {
    return reinterpret_cast<const WriteContentResponse*>(
               &_WriteContentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WriteContentResponse& a, WriteContentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteContentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteContentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteContentResponse* New() const final {
    return new WriteContentResponse();
  }

  WriteContentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteContentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteContentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteContentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteContentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.WriteContentResponse";
  }
  protected:
  explicit WriteContentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 6,
    kStartedAtFieldNumber = 2,
    kUpdatedAtFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kTotalFieldNumber = 5,
    kActionFieldNumber = 1,
  };
  // string digest = 6 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_MUST_USE_RESULT std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // .google.protobuf.Timestamp started_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // .google.protobuf.Timestamp updated_at = 3 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // int64 offset = 4;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 total = 5;
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .containerd.services.content.v1.WriteAction action = 1;
  void clear_action();
  ::containerd::services::content::v1::WriteAction action() const;
  void set_action(::containerd::services::content::v1::WriteAction value);
  private:
  ::containerd::services::content::v1::WriteAction _internal_action() const;
  void _internal_set_action(::containerd::services::content::v1::WriteAction value);
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.WriteContentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// -------------------------------------------------------------------

class AbortRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:containerd.services.content.v1.AbortRequest) */ {
 public:
  inline AbortRequest() : AbortRequest(nullptr) {}
  ~AbortRequest() override;
  explicit constexpr AbortRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbortRequest(const AbortRequest& from);
  AbortRequest(AbortRequest&& from) noexcept
    : AbortRequest() {
    *this = ::std::move(from);
  }

  inline AbortRequest& operator=(const AbortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortRequest& operator=(AbortRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbortRequest* internal_default_instance() {
    return reinterpret_cast<const AbortRequest*>(
               &_AbortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AbortRequest& a, AbortRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbortRequest* New() const final {
    return new AbortRequest();
  }

  AbortRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbortRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbortRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AbortRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbortRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "containerd.services.content.v1.AbortRequest";
  }
  protected:
  explicit AbortRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefFieldNumber = 1,
  };
  // string ref = 1;
  void clear_ref();
  const std::string& ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref();
  PROTOBUF_MUST_USE_RESULT std::string* release_ref();
  void set_allocated_ref(std::string* ref);
  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(const std::string& value);
  std::string* _internal_mutable_ref();
  public:

  // @@protoc_insertion_point(class_scope:containerd.services.content.v1.AbortRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_content_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Info

// string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void Info::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& Info::digest() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Info.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Info.digest)
}
inline std::string* Info::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Info.digest)
  return _s;
}
inline const std::string& Info::_internal_digest() const {
  return digest_.Get();
}
inline void Info::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Info::release_digest() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Info.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Info::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Info.digest)
}

// int64 size = 2;
inline void Info::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Info::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Info::size() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Info.size)
  return _internal_size();
}
inline void Info::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void Info::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Info.size)
}

// .google.protobuf.Timestamp created_at = 3 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Info::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool Info::has_created_at() const {
  return _internal_has_created_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Info::_internal_created_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Info::created_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Info.created_at)
  return _internal_created_at();
}
inline void Info::unsafe_arena_set_allocated_created_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.Info.created_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::release_created_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Info.created_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_at_ = p;
  }
  return created_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::mutable_created_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Info.created_at)
  return _msg;
}
inline void Info::set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Info.created_at)
}

// .google.protobuf.Timestamp updated_at = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Info::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool Info::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Info::_internal_updated_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Info::updated_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Info.updated_at)
  return _internal_updated_at();
}
inline void Info::unsafe_arena_set_allocated_updated_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.Info.updated_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::release_updated_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Info.updated_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Info::mutable_updated_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Info.updated_at)
  return _msg;
}
inline void Info::set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Info.updated_at)
}

// map<string, string> labels = 5;
inline int Info::_internal_labels_size() const {
  return labels_.size();
}
inline int Info::labels_size() const {
  return _internal_labels_size();
}
inline void Info::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Info::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Info::labels() const {
  // @@protoc_insertion_point(field_map:containerd.services.content.v1.Info.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Info::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Info::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.content.v1.Info.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// InfoRequest

// string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void InfoRequest::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& InfoRequest::digest() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.InfoRequest.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoRequest::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.InfoRequest.digest)
}
inline std::string* InfoRequest::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.InfoRequest.digest)
  return _s;
}
inline const std::string& InfoRequest::_internal_digest() const {
  return digest_.Get();
}
inline void InfoRequest::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InfoRequest::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InfoRequest::release_digest() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.InfoRequest.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InfoRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.InfoRequest.digest)
}

// -------------------------------------------------------------------

// InfoResponse

// .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
inline bool InfoResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool InfoResponse::has_info() const {
  return _internal_has_info();
}
inline void InfoResponse::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::containerd::services::content::v1::Info& InfoResponse::_internal_info() const {
  const ::containerd::services::content::v1::Info* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::content::v1::Info&>(
      ::containerd::services::content::v1::_Info_default_instance_);
}
inline const ::containerd::services::content::v1::Info& InfoResponse::info() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.InfoResponse.info)
  return _internal_info();
}
inline void InfoResponse::unsafe_arena_set_allocated_info(
    ::containerd::services::content::v1::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.InfoResponse.info)
}
inline ::containerd::services::content::v1::Info* InfoResponse::release_info() {
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::content::v1::Info* InfoResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.InfoResponse.info)
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::containerd::services::content::v1::Info* InfoResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::content::v1::Info>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::containerd::services::content::v1::Info* InfoResponse::mutable_info() {
  ::containerd::services::content::v1::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.InfoResponse.info)
  return _msg;
}
inline void InfoResponse::set_allocated_info(::containerd::services::content::v1::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::content::v1::Info>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.InfoResponse.info)
}

// -------------------------------------------------------------------

// UpdateRequest

// .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
inline bool UpdateRequest::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UpdateRequest::has_info() const {
  return _internal_has_info();
}
inline void UpdateRequest::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::containerd::services::content::v1::Info& UpdateRequest::_internal_info() const {
  const ::containerd::services::content::v1::Info* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::content::v1::Info&>(
      ::containerd::services::content::v1::_Info_default_instance_);
}
inline const ::containerd::services::content::v1::Info& UpdateRequest::info() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.UpdateRequest.info)
  return _internal_info();
}
inline void UpdateRequest::unsafe_arena_set_allocated_info(
    ::containerd::services::content::v1::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.UpdateRequest.info)
}
inline ::containerd::services::content::v1::Info* UpdateRequest::release_info() {
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::content::v1::Info* UpdateRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.UpdateRequest.info)
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::containerd::services::content::v1::Info* UpdateRequest::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::content::v1::Info>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::containerd::services::content::v1::Info* UpdateRequest::mutable_info() {
  ::containerd::services::content::v1::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.UpdateRequest.info)
  return _msg;
}
inline void UpdateRequest::set_allocated_info(::containerd::services::content::v1::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::content::v1::Info>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.UpdateRequest.info)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const PROTOBUF_NAMESPACE_ID::FieldMask& UpdateRequest::_internal_update_mask() const {
  const PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::FieldMask&>(
      PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::FieldMask& UpdateRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.UpdateRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateRequest::unsafe_arena_set_allocated_update_mask(
    PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.UpdateRequest.update_mask)
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRequest::release_update_mask() {
  
  PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.UpdateRequest.update_mask)
  
  PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRequest::mutable_update_mask() {
  PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.UpdateRequest.update_mask)
  return _msg;
}
inline void UpdateRequest::set_allocated_update_mask(PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.UpdateRequest.update_mask)
}

// -------------------------------------------------------------------

// UpdateResponse

// .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
inline bool UpdateResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UpdateResponse::has_info() const {
  return _internal_has_info();
}
inline void UpdateResponse::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::containerd::services::content::v1::Info& UpdateResponse::_internal_info() const {
  const ::containerd::services::content::v1::Info* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::content::v1::Info&>(
      ::containerd::services::content::v1::_Info_default_instance_);
}
inline const ::containerd::services::content::v1::Info& UpdateResponse::info() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.UpdateResponse.info)
  return _internal_info();
}
inline void UpdateResponse::unsafe_arena_set_allocated_info(
    ::containerd::services::content::v1::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.UpdateResponse.info)
}
inline ::containerd::services::content::v1::Info* UpdateResponse::release_info() {
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::content::v1::Info* UpdateResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.UpdateResponse.info)
  
  ::containerd::services::content::v1::Info* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::containerd::services::content::v1::Info* UpdateResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::content::v1::Info>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::containerd::services::content::v1::Info* UpdateResponse::mutable_info() {
  ::containerd::services::content::v1::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.UpdateResponse.info)
  return _msg;
}
inline void UpdateResponse::set_allocated_info(::containerd::services::content::v1::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::content::v1::Info>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.UpdateResponse.info)
}

// -------------------------------------------------------------------

// ListContentRequest

// repeated string filters = 1;
inline int ListContentRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int ListContentRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListContentRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* ListContentRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.content.v1.ListContentRequest.filters)
  return _s;
}
inline const std::string& ListContentRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& ListContentRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ListContentRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListContentRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ListContentRequest.filters)
  return filters_.Mutable(index);
}
inline void ListContentRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.content.v1.ListContentRequest.filters)
}
inline std::string* ListContentRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void ListContentRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.content.v1.ListContentRequest.filters)
}
inline void ListContentRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.content.v1.ListContentRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListContentRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.content.v1.ListContentRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListContentRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.content.v1.ListContentRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// ListContentResponse

// repeated .containerd.services.content.v1.Info info = 1 [(.gogoproto.nullable) = false];
inline int ListContentResponse::_internal_info_size() const {
  return info_.size();
}
inline int ListContentResponse::info_size() const {
  return _internal_info_size();
}
inline void ListContentResponse::clear_info() {
  info_.Clear();
}
inline ::containerd::services::content::v1::Info* ListContentResponse::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ListContentResponse.info)
  return info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Info >*
ListContentResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.content.v1.ListContentResponse.info)
  return &info_;
}
inline const ::containerd::services::content::v1::Info& ListContentResponse::_internal_info(int index) const {
  return info_.Get(index);
}
inline const ::containerd::services::content::v1::Info& ListContentResponse::info(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ListContentResponse.info)
  return _internal_info(index);
}
inline ::containerd::services::content::v1::Info* ListContentResponse::_internal_add_info() {
  return info_.Add();
}
inline ::containerd::services::content::v1::Info* ListContentResponse::add_info() {
  ::containerd::services::content::v1::Info* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListContentResponse.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Info >&
ListContentResponse::info() const {
  // @@protoc_insertion_point(field_list:containerd.services.content.v1.ListContentResponse.info)
  return info_;
}

// -------------------------------------------------------------------

// DeleteContentRequest

// string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void DeleteContentRequest::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& DeleteContentRequest::digest() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.DeleteContentRequest.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteContentRequest::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.DeleteContentRequest.digest)
}
inline std::string* DeleteContentRequest::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.DeleteContentRequest.digest)
  return _s;
}
inline const std::string& DeleteContentRequest::_internal_digest() const {
  return digest_.Get();
}
inline void DeleteContentRequest::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteContentRequest::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteContentRequest::release_digest() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.DeleteContentRequest.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteContentRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.DeleteContentRequest.digest)
}

// -------------------------------------------------------------------

// ReadContentRequest

// string digest = 1 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void ReadContentRequest::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& ReadContentRequest::digest() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ReadContentRequest.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadContentRequest::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ReadContentRequest.digest)
}
inline std::string* ReadContentRequest::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ReadContentRequest.digest)
  return _s;
}
inline const std::string& ReadContentRequest::_internal_digest() const {
  return digest_.Get();
}
inline void ReadContentRequest::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadContentRequest::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadContentRequest::release_digest() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.ReadContentRequest.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadContentRequest::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.ReadContentRequest.digest)
}

// int64 offset = 2;
inline void ReadContentRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentRequest::offset() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ReadContentRequest.offset)
  return _internal_offset();
}
inline void ReadContentRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void ReadContentRequest::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ReadContentRequest.offset)
}

// int64 size = 3;
inline void ReadContentRequest::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentRequest::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentRequest::size() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ReadContentRequest.size)
  return _internal_size();
}
inline void ReadContentRequest::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void ReadContentRequest::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ReadContentRequest.size)
}

// -------------------------------------------------------------------

// ReadContentResponse

// int64 offset = 1;
inline void ReadContentResponse::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentResponse::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadContentResponse::offset() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ReadContentResponse.offset)
  return _internal_offset();
}
inline void ReadContentResponse::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void ReadContentResponse::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ReadContentResponse.offset)
}

// bytes data = 2;
inline void ReadContentResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ReadContentResponse::data() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ReadContentResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadContentResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ReadContentResponse.data)
}
inline std::string* ReadContentResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ReadContentResponse.data)
  return _s;
}
inline const std::string& ReadContentResponse::_internal_data() const {
  return data_.Get();
}
inline void ReadContentResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadContentResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadContentResponse::release_data() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.ReadContentResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadContentResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.ReadContentResponse.data)
}

// -------------------------------------------------------------------

// Status

// .google.protobuf.Timestamp started_at = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Status::_internal_has_started_at() const {
  return this != internal_default_instance() && started_at_ != nullptr;
}
inline bool Status::has_started_at() const {
  return _internal_has_started_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Status::_internal_started_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = started_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Status::started_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.started_at)
  return _internal_started_at();
}
inline void Status::unsafe_arena_set_allocated_started_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.Status.started_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::release_started_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Status.started_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::_internal_mutable_started_at() {
  
  if (started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    started_at_ = p;
  }
  return started_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::mutable_started_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Status.started_at)
  return _msg;
}
inline void Status::set_allocated_started_at(PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Status.started_at)
}

// .google.protobuf.Timestamp updated_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Status::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool Status::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Status::_internal_updated_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Status::updated_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.updated_at)
  return _internal_updated_at();
}
inline void Status::unsafe_arena_set_allocated_updated_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.Status.updated_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::release_updated_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Status.updated_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Status::mutable_updated_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Status.updated_at)
  return _msg;
}
inline void Status::set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Status.updated_at)
}

// string ref = 3;
inline void Status::clear_ref() {
  ref_.ClearToEmpty();
}
inline const std::string& Status::ref() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.ref)
  return _internal_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_ref(ArgT0&& arg0, ArgT... args) {
 
 ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Status.ref)
}
inline std::string* Status::mutable_ref() {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Status.ref)
  return _s;
}
inline const std::string& Status::_internal_ref() const {
  return ref_.Get();
}
inline void Status::_internal_set_ref(const std::string& value) {
  
  ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_ref() {
  
  return ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Status::release_ref() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Status.ref)
  return ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Status::set_allocated_ref(std::string* ref) {
  if (ref != nullptr) {
    
  } else {
    
  }
  ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Status.ref)
}

// int64 offset = 4;
inline void Status::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::offset() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.offset)
  return _internal_offset();
}
inline void Status::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void Status::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Status.offset)
}

// int64 total = 5;
inline void Status::clear_total() {
  total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::total() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.total)
  return _internal_total();
}
inline void Status::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void Status::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Status.total)
}

// string expected = 6 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void Status::clear_expected() {
  expected_.ClearToEmpty();
}
inline const std::string& Status::expected() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.Status.expected)
  return _internal_expected();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_expected(ArgT0&& arg0, ArgT... args) {
 
 expected_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.Status.expected)
}
inline std::string* Status::mutable_expected() {
  std::string* _s = _internal_mutable_expected();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.Status.expected)
  return _s;
}
inline const std::string& Status::_internal_expected() const {
  return expected_.Get();
}
inline void Status::_internal_set_expected(const std::string& value) {
  
  expected_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_expected() {
  
  return expected_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Status::release_expected() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.Status.expected)
  return expected_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Status::set_allocated_expected(std::string* expected) {
  if (expected != nullptr) {
    
  } else {
    
  }
  expected_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expected,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.Status.expected)
}

// -------------------------------------------------------------------

// StatusRequest

// string ref = 1;
inline void StatusRequest::clear_ref() {
  ref_.ClearToEmpty();
}
inline const std::string& StatusRequest::ref() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.StatusRequest.ref)
  return _internal_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusRequest::set_ref(ArgT0&& arg0, ArgT... args) {
 
 ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.StatusRequest.ref)
}
inline std::string* StatusRequest::mutable_ref() {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.StatusRequest.ref)
  return _s;
}
inline const std::string& StatusRequest::_internal_ref() const {
  return ref_.Get();
}
inline void StatusRequest::_internal_set_ref(const std::string& value) {
  
  ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusRequest::_internal_mutable_ref() {
  
  return ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusRequest::release_ref() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.StatusRequest.ref)
  return ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusRequest::set_allocated_ref(std::string* ref) {
  if (ref != nullptr) {
    
  } else {
    
  }
  ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.StatusRequest.ref)
}

// -------------------------------------------------------------------

// StatusResponse

// .containerd.services.content.v1.Status status = 1;
inline bool StatusResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool StatusResponse::has_status() const {
  return _internal_has_status();
}
inline void StatusResponse::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::containerd::services::content::v1::Status& StatusResponse::_internal_status() const {
  const ::containerd::services::content::v1::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::containerd::services::content::v1::Status&>(
      ::containerd::services::content::v1::_Status_default_instance_);
}
inline const ::containerd::services::content::v1::Status& StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::unsafe_arena_set_allocated_status(
    ::containerd::services::content::v1::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.StatusResponse.status)
}
inline ::containerd::services::content::v1::Status* StatusResponse::release_status() {
  
  ::containerd::services::content::v1::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::containerd::services::content::v1::Status* StatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.StatusResponse.status)
  
  ::containerd::services::content::v1::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::containerd::services::content::v1::Status* StatusResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::containerd::services::content::v1::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::containerd::services::content::v1::Status* StatusResponse::mutable_status() {
  ::containerd::services::content::v1::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.StatusResponse.status)
  return _msg;
}
inline void StatusResponse::set_allocated_status(::containerd::services::content::v1::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::containerd::services::content::v1::Status>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.StatusResponse.status)
}

// -------------------------------------------------------------------

// ListStatusesRequest

// repeated string filters = 1;
inline int ListStatusesRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int ListStatusesRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListStatusesRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* ListStatusesRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:containerd.services.content.v1.ListStatusesRequest.filters)
  return _s;
}
inline const std::string& ListStatusesRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& ListStatusesRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ListStatusesRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListStatusesRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ListStatusesRequest.filters)
  return filters_.Mutable(index);
}
inline void ListStatusesRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline std::string* ListStatusesRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void ListStatusesRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline void ListStatusesRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:containerd.services.content.v1.ListStatusesRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListStatusesRequest::filters() const {
  // @@protoc_insertion_point(field_list:containerd.services.content.v1.ListStatusesRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListStatusesRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.content.v1.ListStatusesRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// ListStatusesResponse

// repeated .containerd.services.content.v1.Status statuses = 1 [(.gogoproto.nullable) = false];
inline int ListStatusesResponse::_internal_statuses_size() const {
  return statuses_.size();
}
inline int ListStatusesResponse::statuses_size() const {
  return _internal_statuses_size();
}
inline void ListStatusesResponse::clear_statuses() {
  statuses_.Clear();
}
inline ::containerd::services::content::v1::Status* ListStatusesResponse::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.ListStatusesResponse.statuses)
  return statuses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Status >*
ListStatusesResponse::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:containerd.services.content.v1.ListStatusesResponse.statuses)
  return &statuses_;
}
inline const ::containerd::services::content::v1::Status& ListStatusesResponse::_internal_statuses(int index) const {
  return statuses_.Get(index);
}
inline const ::containerd::services::content::v1::Status& ListStatusesResponse::statuses(int index) const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.ListStatusesResponse.statuses)
  return _internal_statuses(index);
}
inline ::containerd::services::content::v1::Status* ListStatusesResponse::_internal_add_statuses() {
  return statuses_.Add();
}
inline ::containerd::services::content::v1::Status* ListStatusesResponse::add_statuses() {
  ::containerd::services::content::v1::Status* _add = _internal_add_statuses();
  // @@protoc_insertion_point(field_add:containerd.services.content.v1.ListStatusesResponse.statuses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::containerd::services::content::v1::Status >&
ListStatusesResponse::statuses() const {
  // @@protoc_insertion_point(field_list:containerd.services.content.v1.ListStatusesResponse.statuses)
  return statuses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WriteContentRequest

// .containerd.services.content.v1.WriteAction action = 1;
inline void WriteContentRequest::clear_action() {
  action_ = 0;
}
inline ::containerd::services::content::v1::WriteAction WriteContentRequest::_internal_action() const {
  return static_cast< ::containerd::services::content::v1::WriteAction >(action_);
}
inline ::containerd::services::content::v1::WriteAction WriteContentRequest::action() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.action)
  return _internal_action();
}
inline void WriteContentRequest::_internal_set_action(::containerd::services::content::v1::WriteAction value) {
  
  action_ = value;
}
inline void WriteContentRequest::set_action(::containerd::services::content::v1::WriteAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.action)
}

// string ref = 2;
inline void WriteContentRequest::clear_ref() {
  ref_.ClearToEmpty();
}
inline const std::string& WriteContentRequest::ref() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.ref)
  return _internal_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteContentRequest::set_ref(ArgT0&& arg0, ArgT... args) {
 
 ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.ref)
}
inline std::string* WriteContentRequest::mutable_ref() {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentRequest.ref)
  return _s;
}
inline const std::string& WriteContentRequest::_internal_ref() const {
  return ref_.Get();
}
inline void WriteContentRequest::_internal_set_ref(const std::string& value) {
  
  ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::_internal_mutable_ref() {
  
  return ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::release_ref() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentRequest.ref)
  return ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteContentRequest::set_allocated_ref(std::string* ref) {
  if (ref != nullptr) {
    
  } else {
    
  }
  ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentRequest.ref)
}

// int64 total = 3;
inline void WriteContentRequest::clear_total() {
  total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentRequest::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentRequest::total() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.total)
  return _internal_total();
}
inline void WriteContentRequest::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void WriteContentRequest::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.total)
}

// string expected = 4 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void WriteContentRequest::clear_expected() {
  expected_.ClearToEmpty();
}
inline const std::string& WriteContentRequest::expected() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.expected)
  return _internal_expected();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteContentRequest::set_expected(ArgT0&& arg0, ArgT... args) {
 
 expected_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.expected)
}
inline std::string* WriteContentRequest::mutable_expected() {
  std::string* _s = _internal_mutable_expected();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentRequest.expected)
  return _s;
}
inline const std::string& WriteContentRequest::_internal_expected() const {
  return expected_.Get();
}
inline void WriteContentRequest::_internal_set_expected(const std::string& value) {
  
  expected_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::_internal_mutable_expected() {
  
  return expected_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::release_expected() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentRequest.expected)
  return expected_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteContentRequest::set_allocated_expected(std::string* expected) {
  if (expected != nullptr) {
    
  } else {
    
  }
  expected_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expected,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentRequest.expected)
}

// int64 offset = 5;
inline void WriteContentRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentRequest::offset() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.offset)
  return _internal_offset();
}
inline void WriteContentRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void WriteContentRequest::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.offset)
}

// bytes data = 6;
inline void WriteContentRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& WriteContentRequest::data() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteContentRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentRequest.data)
}
inline std::string* WriteContentRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentRequest.data)
  return _s;
}
inline const std::string& WriteContentRequest::_internal_data() const {
  return data_.Get();
}
inline void WriteContentRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteContentRequest::release_data() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteContentRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentRequest.data)
}

// map<string, string> labels = 7;
inline int WriteContentRequest::_internal_labels_size() const {
  return labels_.size();
}
inline int WriteContentRequest::labels_size() const {
  return _internal_labels_size();
}
inline void WriteContentRequest::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteContentRequest::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WriteContentRequest::labels() const {
  // @@protoc_insertion_point(field_map:containerd.services.content.v1.WriteContentRequest.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteContentRequest::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WriteContentRequest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:containerd.services.content.v1.WriteContentRequest.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// WriteContentResponse

// .containerd.services.content.v1.WriteAction action = 1;
inline void WriteContentResponse::clear_action() {
  action_ = 0;
}
inline ::containerd::services::content::v1::WriteAction WriteContentResponse::_internal_action() const {
  return static_cast< ::containerd::services::content::v1::WriteAction >(action_);
}
inline ::containerd::services::content::v1::WriteAction WriteContentResponse::action() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.action)
  return _internal_action();
}
inline void WriteContentResponse::_internal_set_action(::containerd::services::content::v1::WriteAction value) {
  
  action_ = value;
}
inline void WriteContentResponse::set_action(::containerd::services::content::v1::WriteAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentResponse.action)
}

// .google.protobuf.Timestamp started_at = 2 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool WriteContentResponse::_internal_has_started_at() const {
  return this != internal_default_instance() && started_at_ != nullptr;
}
inline bool WriteContentResponse::has_started_at() const {
  return _internal_has_started_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WriteContentResponse::_internal_started_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = started_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WriteContentResponse::started_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.started_at)
  return _internal_started_at();
}
inline void WriteContentResponse::unsafe_arena_set_allocated_started_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.WriteContentResponse.started_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::release_started_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentResponse.started_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = started_at_;
  started_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::_internal_mutable_started_at() {
  
  if (started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    started_at_ = p;
  }
  return started_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::mutable_started_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentResponse.started_at)
  return _msg;
}
inline void WriteContentResponse::set_allocated_started_at(PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentResponse.started_at)
}

// .google.protobuf.Timestamp updated_at = 3 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool WriteContentResponse::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool WriteContentResponse::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WriteContentResponse::_internal_updated_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& WriteContentResponse::updated_at() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.updated_at)
  return _internal_updated_at();
}
inline void WriteContentResponse::unsafe_arena_set_allocated_updated_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:containerd.services.content.v1.WriteContentResponse.updated_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::release_updated_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentResponse.updated_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    updated_at_ = p;
  }
  return updated_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* WriteContentResponse::mutable_updated_at() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentResponse.updated_at)
  return _msg;
}
inline void WriteContentResponse::set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentResponse.updated_at)
}

// int64 offset = 4;
inline void WriteContentResponse::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentResponse::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentResponse::offset() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.offset)
  return _internal_offset();
}
inline void WriteContentResponse::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void WriteContentResponse::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentResponse.offset)
}

// int64 total = 5;
inline void WriteContentResponse::clear_total() {
  total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentResponse::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WriteContentResponse::total() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.total)
  return _internal_total();
}
inline void WriteContentResponse::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void WriteContentResponse::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentResponse.total)
}

// string digest = 6 [(.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/opencontainers/go-digest.Digest"];
inline void WriteContentResponse::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& WriteContentResponse::digest() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.WriteContentResponse.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteContentResponse::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.WriteContentResponse.digest)
}
inline std::string* WriteContentResponse::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.WriteContentResponse.digest)
  return _s;
}
inline const std::string& WriteContentResponse::_internal_digest() const {
  return digest_.Get();
}
inline void WriteContentResponse::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteContentResponse::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteContentResponse::release_digest() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.WriteContentResponse.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteContentResponse::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.WriteContentResponse.digest)
}

// -------------------------------------------------------------------

// AbortRequest

// string ref = 1;
inline void AbortRequest::clear_ref() {
  ref_.ClearToEmpty();
}
inline const std::string& AbortRequest::ref() const {
  // @@protoc_insertion_point(field_get:containerd.services.content.v1.AbortRequest.ref)
  return _internal_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbortRequest::set_ref(ArgT0&& arg0, ArgT... args) {
 
 ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:containerd.services.content.v1.AbortRequest.ref)
}
inline std::string* AbortRequest::mutable_ref() {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:containerd.services.content.v1.AbortRequest.ref)
  return _s;
}
inline const std::string& AbortRequest::_internal_ref() const {
  return ref_.Get();
}
inline void AbortRequest::_internal_set_ref(const std::string& value) {
  
  ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AbortRequest::_internal_mutable_ref() {
  
  return ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AbortRequest::release_ref() {
  // @@protoc_insertion_point(field_release:containerd.services.content.v1.AbortRequest.ref)
  return ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AbortRequest::set_allocated_ref(std::string* ref) {
  if (ref != nullptr) {
    
  } else {
    
  }
  ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:containerd.services.content.v1.AbortRequest.ref)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace content
}  // namespace services
}  // namespace containerd

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::containerd::services::content::v1::WriteAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::containerd::services::content::v1::WriteAction>() {
  return ::containerd::services::content::v1::WriteAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_content_2eproto
